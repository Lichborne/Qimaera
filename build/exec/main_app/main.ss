#!/opt/homebrew/bin/chez --program

;; @generated by Idris 0.7.0, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx tarm64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.dylib")

(let ()
(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work)])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))


(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PrimIO-prim__nullAnyPtr (lambda (farg-0) ((foreign-procedure "idris2_isNull" (void*) int) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__writeLine (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_writeLine" (void* string) int) farg-0 farg-1)))
(define SystemC-45FileC-45Error-prim__fileErrno (lambda (farg-0) ((foreign-procedure "idris2_fileErrno" () int) )))
(define SystemC-45FileC-45Handle-prim__open (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_openFile" (string string) void*) farg-0 farg-1)))
(define SystemC-45FileC-45Handle-prim__close (lambda (farg-0 farg-1) ((foreign-procedure "idris2_closeFile" (void*) void) farg-0)))
(define SystemC-45Random-prim__randomDouble (lambda (farg-0) (blodwen-random )))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-2 (arg-3 ext-0))) (arg-2 act-2))))
(define csegen-38 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8885) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-8885 eta-0)))))) (lambda (u--a) (lambda (arg-9931) (lambda (eta-0) arg-9931))) (lambda (u--b) (lambda (u--a) (lambda (arg-9937) (lambda (arg-9944) (lambda (world-4) (let ((act-5 (arg-9937 world-4))) (let ((act-3 (arg-9944 world-4))) (act-5 act-3))))))))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define PreludeC-45Types-u--foldlM_Foldable_List (lambda (arg-3 arg-4 arg-5 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define PreludeC-45Types-u--null_Foldable_List (lambda (arg-1) (if (null? arg-1) 1 0)))
(define csegen-56 (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10911) (PreludeC-45Types-u--null_Foldable_List arg-10911))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_List i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10940) arg-10940)) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10954) (PreludeC-45Types-u--foldMap_Foldable_List i_con-0 u--f arg-10954))))))))
(define QStateT-pure (lambda (arg-2 ext-0) (vector 1 (cons ext-0 arg-2))))
(define csegen-87 (lambda (u--q) (lambda (eta-0) (QStateT-pure u--q eta-0))))
(define ControlC-45LinearC-45LIO-u--bindL_LinearBind_IO (lambda (ext-0 ext-1 ext-2) (let ((act-3 (ext-0 ext-2))) ((ext-1 act-3) ext-2))))
(define csegen-91 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (lambda (eta-4) (ControlC-45LinearC-45LIO-u--bindL_LinearBind_IO eta-2 eta-3 eta-4)))))))
(define csegen-92 (cons (cons 1.0 0.0) '()))
(define csegen-93 (cons csegen-92 '()))
(define PreludeC-45Types-u--C-47C-61_Eq_Nat (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Types-u--C-60C-61_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define PreludeC-45Types-u--C-60_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define PreludeC-45Types-u--C-62C-61_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define PreludeC-45Types-u--C-62_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define PreludeC-45Types-u--max_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-62_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define PreludeC-45Types-u--min_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-60_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define csegen-106 (vector (cons (lambda (arg-676) (lambda (arg-679) (or (and (= arg-676 arg-679) 1) 0))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45Types-u--C-47C-61_Eq_Nat arg-686 arg-689)))) (lambda (arg-1566) (lambda (arg-1569) (PreludeC-45EqOrd-u--compare_Ord_Integer arg-1566 arg-1569))) (lambda (arg-1576) (lambda (arg-1579) (PreludeC-45Types-u--C-60_Ord_Nat arg-1576 arg-1579))) (lambda (arg-1586) (lambda (arg-1589) (PreludeC-45Types-u--C-62_Ord_Nat arg-1586 arg-1589))) (lambda (arg-1596) (lambda (arg-1599) (PreludeC-45Types-u--C-60C-61_Ord_Nat arg-1596 arg-1599))) (lambda (arg-1606) (lambda (arg-1609) (PreludeC-45Types-u--C-62C-61_Ord_Nat arg-1606 arg-1609))) (lambda (arg-1616) (lambda (arg-1619) (PreludeC-45Types-u--max_Ord_Nat arg-1616 arg-1619))) (lambda (arg-1626) (lambda (arg-1629) (PreludeC-45Types-u--min_Ord_Nat arg-1626 arg-1629)))))
(define csegen-112 (vector csegen-38 (lambda (u--b) (lambda (u--a) (lambda (arg-10411) (lambda (arg-10414) (lambda (world-0) (let ((act-1 (arg-10411 world-0))) ((arg-10414 act-1) world-0))))))) (lambda (u--a) (lambda (arg-10425) (lambda (world-0) (let ((act-1 (arg-10425 world-0))) (act-1 world-0)))))))
(define csegen-115 (cons csegen-112 (lambda (u--a) (lambda (arg-13095) arg-13095))))
(define csegen-118 (lambda (eta-0) (lambda (eta-1) (cons eta-0 eta-1))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define PreludeC-45Show-u--show_Show_Nat (lambda (arg-0) (PreludeC-45Show-u--show_Show_Integer arg-0)))
(define PreludeC-45Show-u--showPrec_Show_Nat (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_Nat arg-1)))
(define csegen-123 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_Nat u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_Nat u--d u--x)))))
(define UnitaryLinear-HGate (vector 1 0 1 (vector 0 )))
(define UnitaryLinear-S (lambda (arg-1 arg-2 arg-3) (vector 2 (/ 3.141592653589793 2.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-SGate (UnitaryLinear-S 0 1 (vector 0 )))
(define UnitaryLinear-compose (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((0) arg-2) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (vector 1 e-2 e-3 (UnitaryLinear-compose e-4 arg-2)))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (vector 2 e-6 e-7 e-8 (UnitaryLinear-compose e-9 arg-2))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (vector 3 e-11 e-12 e-13 e-14 e-15 (UnitaryLinear-compose e-16 arg-2))))))))))))
(define csegen-127 (UnitaryLinear-compose UnitaryLinear-HGate UnitaryLinear-SGate))
(define Lemmas-ltz1 1)
(define csegen-147 (cons (vector 0 Lemmas-ltz1) '()))
(define csegen-163 (cons (cons 0.0 0.0) csegen-92))
(define csegen-164 (cons (cons 0.0 0.0) '()))
(define csegen-165 (cons (cons 1.0 0.0) csegen-164))
(define csegen-168 (cons (cons 0.0 0.0) csegen-164))
(define csegen-173 (cons (/ 1.0 (flsqrt 2.0)) 0.0))
(define Lemmas-lemma1LTESucc (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-lemma1LTESucc e-0))))))
(define csegen-186 (vector 1 0 (Lemmas-lemma1LTESucc 1) (vector 0 )))
(define csegen-220 (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 )))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define QStateT-C-62C-62C-61 (lambda (arg-5 arg-6 ext-0) (vector 4 1 (arg-5 ext-0) (lambda (lamc-0) (let ((e-2 (car lamc-0))) (let ((e-3 (cdr lamc-0))) ((arg-6 e-3) e-2)))))))
(define CoinToss-coin (lambda (arg-1 arg-2 ext-0) (let ((act-1 (let ((e-11 (vector-ref arg-2 10))) (((e-11 1) (lambda (eta-0) (QStateT-C-62C-62C-61 (let ((e-21 (vector-ref arg-2 1))) (e-21 'erased)) (lambda (u--q) (lambda (eta-1) (QStateT-C-62C-62C-61 (let ((e-20 (vector-ref arg-2 2))) (((e-20 1) 1) (let ((e-33 (vector-ref arg-1 2))) ((e-33 1) u--q)))) (lambda (q-0) (lambda (eta-2) (QStateT-C-62C-62C-61 (let ((e-15 (vector-ref arg-2 7))) (((e-15 0) 1) q-0)) (lambda (u--r) (lambda (eta-3) (QStateT-pure u--r eta-3))) eta-2))) eta-1))) eta-0))) ext-0)))) (let ((e-2 (car act-1))) (let ((e-3 (cdr act-1))) e-2)))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define PreludeC-45TypesC-45List-lengthPlus (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-lengthPlus (+ arg-1 1) e-3)))))
(define PreludeC-45TypesC-45List-lengthTR (lambda (ext-0) (PreludeC-45TypesC-45List-lengthPlus 0 ext-0)))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define DataC-45List-replicateTR (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) arg-1)(else (let ((e-0 (- arg-2 1))) (DataC-45List-replicateTR (cons arg-3 arg-1) e-0 arg-3))))))
(define PreludeC-45Interfaces-sequence (lambda (arg-3 arg-4 ext-0) (let ((e-3 (vector-ref arg-4 2))) ((((((e-3 'erased) 'erased) 'erased) arg-3) (lambda (eta-0) eta-0)) ext-0))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Bool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0)))(else 0))))
(define UnitaryLinear-adjoint (lambda (arg-1) (case (vector-ref arg-1 0) ((0) (vector 0 )) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-4) (vector 1 e-2 e-3 (vector 0 ))))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-9) (vector 2 (- e-6) e-7 e-8 (vector 0 )))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-16) (vector 3 e-11 e-12 e-13 e-14 e-15 (vector 0 )))))))))))))
(define Matrix-ket1 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons (cons (cons 1.0 0.0) csegen-92) (Matrix-ket1 e-0)))))))
(define DataC-45Vect-C-43C-43 (lambda (arg-3 arg-4) (if (null? arg-3) arg-4 (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons e-3 (DataC-45Vect-C-43C-43 e-4 arg-4)))))))
(define Matrix-concatCols (lambda (arg-3 arg-4) (DataC-45Vect-C-43C-43 arg-3 arg-4)))
(define Matrix-concatRows (lambda (arg-3 arg-4) (if (null? arg-3) '() (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (DataC-45Vect-C-43C-43 e-3 e-8) (Matrix-concatRows e-4 e-9)))))))))
(define Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 (lambda (arg-0 arg-1) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (cons (- (* e-1 e-4) (* e-2 e-5)) (+ (* e-2 e-4) (* e-1 e-5)))))))))
(define Matrix-multScalarVect (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (cons (Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 arg-1 e-3) (Matrix-multScalarVect arg-1 e-4)))))))
(define Matrix-multScalarMatrix (lambda (arg-2 arg-3) (if (null? arg-3) '() (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons (Matrix-multScalarVect arg-2 e-3) (Matrix-multScalarMatrix arg-2 e-4)))))))
(define Matrix-tensorProductC-39 (lambda (arg-3 arg-4) (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (if (null? e-3) (Matrix-multScalarMatrix e-2 arg-4) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (Matrix-concatRows (Matrix-multScalarMatrix e-2 arg-4) (Matrix-tensorProductC-39 (cons e-7 e-8) arg-4)))))))))
(define Matrix-tensorProduct (lambda (arg-4 arg-5) (if (null? arg-4) '() (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (if (null? e-4) (Matrix-tensorProductC-39 e-3 arg-5) (let ((e-8 (car e-4))) (let ((e-9 (cdr e-4))) (Matrix-concatCols (Matrix-tensorProductC-39 e-3 arg-5) (Matrix-tensorProduct (cons e-8 e-9) arg-5))))))))))
(define Matrix-toTensorBasis (lambda (arg-1) (if (null? arg-1) csegen-93 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (let ((e-11 (car e-8))) (let ((e-12 (cdr e-8))) (Matrix-tensorProduct (cons (cons e-7 '()) (cons (cons e-11 '()) '())) (Matrix-toTensorBasis e-4)))))))))))
(define Matrix-neutralIdPow (lambda (arg-0) (Matrix-toTensorBasis (Matrix-ket1 arg-0))))
(define SimulatedOp-invert (lambda (arg-2 arg-3) (let ((e-0 (vector-ref arg-3 0))) (let ((e-1 (vector-ref arg-3 1))) (let ((e-2 (vector-ref arg-3 2))) (let ((e-3 (vector-ref arg-3 3))) (let ((e-4 (vector-ref arg-3 4))) (let ((sc0 (arg-2 (vector e-0 (Matrix-neutralIdPow e-0) (vector 0 ) e-3 e-4)))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-9 (vector-ref e-6 2))) (let ((u--invu (UnitaryLinear-adjoint e-9))) (let ((u--unew (UnitaryLinear-compose u--invu e-2))) (cons (vector e-0 e-1 u--unew e-3 e-4) e-5))))))))))))))
(define SimulatedOp-adjointUSTC-39 (lambda (arg-2 ext-0) (SimulatedOp-invert arg-2 ext-0)))
(define SimulatedOp-u--adjointUST_UnitaryOp_SimulatedOp (lambda (ext-1 ext-0) (SimulatedOp-adjointUSTC-39 ext-1 ext-0)))
(define DataC-45Nat-fromLteSucc (lambda (arg-2) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-2 (- arg-2 1))) e-2)))))
(define Injection-indexLT (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (let ((e-3 (car arg-2))) e-3))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-2))) (Injection-indexLT e-0 e-8 (DataC-45Nat-fromLteSucc arg-3))))))))
(define Matrix-matrixH (cons (cons csegen-173 (cons csegen-173 '())) (cons (cons csegen-173 (cons (cons (/ -1.0 (flsqrt 2.0)) 0.0) '())) '())))
(define Matrix-addCol (lambda (arg-2 arg-3) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((e-8 (car arg-3))) (let ((e-9 (cdr arg-3))) (cons (cons e-3 e-8) (Matrix-addCol e-4 e-9)))))))))
(define DataC-45Vect-replicate (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons arg-2 (DataC-45Vect-replicate e-0 arg-2)))))))
(define Matrix-transposeMatrix (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (DataC-45Vect-replicate arg-1 '()))(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (Matrix-addCol e-4 (Matrix-transposeMatrix e-0 arg-1 e-5)))))))))
(define Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 (lambda (arg-0 arg-1) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (cons (+ e-1 e-4) (+ e-2 e-5))))))))
(define Matrix-vectProduct (lambda (arg-1 arg-2) (if (null? arg-1) (cons 0.0 0.0) (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 (Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 e-3 e-8) (Matrix-vectProduct e-4 e-9)))))))))
(define Matrix-n--4753-1163-u--multVectMatrixC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-6 arg-7) (if (null? arg-7) '() (let ((e-3 (car arg-7))) (let ((e-4 (cdr arg-7))) (cons (Matrix-vectProduct arg-6 e-3) (Matrix-n--4753-1163-u--multVectMatrixC-39 arg-0 arg-1 arg-2 arg-3 arg-6 e-4)))))))
(define Matrix-multVectMatrix (lambda (arg-0 arg-1 arg-2 arg-3) (let ((u--mt (Matrix-transposeMatrix arg-0 arg-1 arg-3))) (Matrix-n--4753-1163-u--multVectMatrixC-39 arg-0 arg-1 arg-3 arg-2 arg-2 u--mt))))
(define Matrix-matrixMult (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (cons (Matrix-multVectMatrix arg-1 arg-2 e-4 arg-4) (Matrix-matrixMult e-0 arg-1 arg-2 e-5 arg-4)))))))))
(define Complex-cis (lambda (arg-0) (cons (flcos arg-0) (flsin arg-0))))
(define Matrix-matrixP (lambda (arg-0) (cons csegen-165 (cons (cons (cons 0.0 0.0) (cons (Complex-cis arg-0) '())) '()))))
(define DataC-45Nat-power (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) 1)(else (let ((e-0 (- arg-1 1))) (* arg-0 (DataC-45Nat-power arg-0 e-0)))))))
(define Matrix-idRow (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cons (cons 1.0 0.0) (Matrix-idRow e-0 (+ e-0 1))))(else (let ((e-1 (- arg-1 1))) (cons (cons 0.0 0.0) (Matrix-idRow e-0 e-1))))))))))
(define Matrix-n--4504-929-u--matrixIdC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Matrix-idRow arg-3 arg-2) (Matrix-n--4504-929-u--matrixIdC-39 arg-0 e-0 (+ arg-2 1) arg-3)))))))
(define Matrix-matrixId (lambda (arg-0) (Matrix-n--4504-929-u--matrixIdC-39 arg-0 arg-0 0 arg-0)))
(define Matrix-simpleTensor (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) csegen-93)(else (let ((e-0 (- arg-1 1))) (cond ((equal? arg-2 0) (Matrix-tensorProduct arg-0 (Matrix-simpleTensor arg-0 e-0 (+ e-0 1))))(else (let ((e-1 (- arg-2 1))) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-simpleTensor arg-0 e-0 e-1))))))))))
(define Matrix-addVector (lambda (arg-1 arg-2) (if (null? arg-1) '() (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (cons (Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 e-3 e-8) (Matrix-addVector e-4 e-9)))))))))
(define Matrix-addMatrix (lambda (arg-2 arg-3) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((e-8 (car arg-3))) (let ((e-9 (cdr arg-3))) (cons (Matrix-addVector e-3 e-8) (Matrix-addMatrix e-4 e-9)))))))))
(define Matrix-matrixKet0Bra0 (cons csegen-165 (cons csegen-168 '())))
(define Matrix-matrixKet1Bra1 (cons csegen-168 (cons csegen-163 '())))
(define Matrix-matrixX (cons csegen-163 (cons csegen-165 '())))
(define Matrix-tensorCnotAux (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) csegen-93)(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-tensorCnotAux e-0 (+ e-0 1) (+ e-0 1))))(else (let ((e-2 (- arg-2 1))) (Matrix-tensorProduct Matrix-matrixKet1Bra1 (Matrix-tensorCnotAux e-0 (+ e-0 1) e-2))))))(else (let ((e-1 (- arg-1 1))) (cond ((equal? arg-2 0) (Matrix-tensorProduct Matrix-matrixX (Matrix-tensorCnotAux e-0 e-1 (+ e-0 1))))(else (let ((e-3 (- arg-2 1))) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-tensorCnotAux e-0 e-1 e-3)))))))))))))
(define Matrix-tensorCNOT (lambda (arg-0 arg-1 arg-2) (Matrix-addMatrix (Matrix-simpleTensor Matrix-matrixKet0Bra0 arg-0 arg-1) (Matrix-tensorCnotAux arg-0 arg-1 arg-2))))
(define QuantumOp-applyCirc (lambda (arg-0 arg-1 arg-2 arg-3) (case (vector-ref arg-2 0) ((0) arg-3) ((1) (let ((e-2 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 2))) (let ((e-4 (vector-ref arg-2 3))) (let ((u--k (Injection-indexLT e-2 arg-1 e-3))) (let ((u--h (Matrix-simpleTensor Matrix-matrixH arg-0 u--k))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-4 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-6 (vector-ref sc1 3))) (let ((e-5 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--h e-1) (vector 0 ) e-6 e-5))))))))))) ((2) (let ((e-6 (vector-ref arg-2 1))) (let ((e-7 (vector-ref arg-2 2))) (let ((e-8 (vector-ref arg-2 3))) (let ((e-9 (vector-ref arg-2 4))) (let ((u--k (Injection-indexLT e-7 arg-1 e-8))) (let ((u--ph (Matrix-simpleTensor (Matrix-matrixP e-6) arg-0 u--k))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-9 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-3 (vector-ref sc1 3))) (let ((e-4 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--ph e-1) (vector 0 ) e-3 e-4)))))))))))) (else (let ((e-11 (vector-ref arg-2 1))) (let ((e-12 (vector-ref arg-2 2))) (let ((e-13 (vector-ref arg-2 3))) (let ((e-14 (vector-ref arg-2 4))) (let ((e-16 (vector-ref arg-2 6))) (let ((u--kc (Injection-indexLT e-11 arg-1 e-13))) (let ((u--kt (Injection-indexLT e-12 arg-1 e-14))) (let ((u--cn (Matrix-tensorCNOT arg-0 u--kc u--kt))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-16 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-3 (vector-ref sc1 3))) (let ((e-4 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--cn e-1) (vector 0 ) e-3 e-4)))))))))))))))))
(define QuantumOp-case--applyUnitaryC-39-15346 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-7) (let ((e-2 (car arg-7))) (let ((e-3 (cdr arg-7))) (let ((e-5 (vector-ref e-2 1))) (let ((e-6 (vector-ref e-2 2))) (let ((e-7 (vector-ref e-2 3))) (let ((e-8 (vector-ref e-2 4))) (let ((u--qs2 (QuantumOp-applyCirc arg-0 arg-3 e-6 (vector arg-0 e-5 e-6 e-7 e-8)))) (vector 1 (cons u--qs2 e-3)))))))))))
(define QuantumOp-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (let ((e-1 (vector-ref arg-3 1))) (let ((e-2 (vector-ref arg-3 2))) (let ((e-3 (vector-ref arg-3 3))) (let ((e-4 (vector-ref arg-3 4))) (QuantumOp-case--applyUnitaryC-39-15346 arg-0 arg-1 e-4 e-3 e-2 e-1 (arg-2 (vector arg-0 e-1 e-2 e-3 e-4)))))))))
(define QuantumOp-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 ext-0) (QuantumOp-applyUnitaryC-39 arg-0 arg-1 arg-2 ext-0)))
(define QuantumOp-u--applyUST_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-1 ext-0) (QuantumOp-applyUnitarySimulated arg-0 arg-1 ext-1 ext-0)))
(define QuantumOp-u--applyCNOTQ_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp arg-1 2 (let ((e-5 (vector-ref arg-0 4))) (((e-5 arg-1) arg-2) arg-3)) eta-0)) (lambda (u--cq) (lambda (eta-0) (QStateT-pure u--cq eta-0))) ext-0)))
(define UStateT-C-62C-62C-61 (lambda (arg-5 arg-6 ext-0) (let ((sc0 (arg-5 ext-0))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) ((arg-6 e-3) e-2))))))
(define UnitaryLinear-CNOTGate (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 0 )))
(define QuantumOp-distributeDupedLVectVect (lambda (arg-1) (if (null? arg-1) (cons '() '()) (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((sc1 (QuantumOp-distributeDupedLVectVect e-4))) (let ((e-2 (car sc1))) (let ((e-5 (cdr sc1))) (cons (cons e-3 e-2) (cons e-3 e-5))))))))))
(define Injection-allDifSProp (lambda (arg-3 arg-4) (let ((e-4 (cdr arg-4))) (arg-3 e-4))))
(define Injection-eitherVoid (lambda (arg-2 arg-3 arg-4) (case (vector-ref arg-4 0) ((0) (let ((e-2 (vector-ref arg-4 1))) (arg-2 e-2))) (else (let ((e-5 (vector-ref arg-4 1))) (arg-3 e-5))))))
(define Injection-eitherVoidThenNotDif (lambda (arg-4 arg-5) (let ((e-4 (car arg-5))) (arg-4 e-4))))
(define Injection-isDifSProp (lambda (arg-4 arg-5) (let ((e-5 (cdr arg-5))) (arg-4 e-5))))
(define DataC-45Nat-succNotLTEzero (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DataC-45Nat-isLTE (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 0))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (vector 1 (lambda (eta-0) (DataC-45Nat-succNotLTEzero eta-0))))(else (let ((e-1 (- arg-1 1))) (let ((sc0 (DataC-45Nat-isLTE e-0 e-1))) (case (vector-ref sc0 0) ((1) (let ((e-2 (vector-ref sc0 1))) (vector 1 (lambda (eta-0) (e-2 (DataC-45Nat-fromLteSucc eta-0)))))) (else (let ((e-3 (vector-ref sc0 1))) (vector 0 (+ e-3 1))))))))))))))
(define DataC-45Nat-isLT (lambda (arg-0 arg-1) (DataC-45Nat-isLTE (+ arg-0 1) arg-1)))
(define Injection-eitherIsDiffOrNot (lambda (arg-1 arg-2) (if (null? arg-2) (vector 0 '()) (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((sc1 (DataC-45Nat-isLT arg-1 e-3))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (let ((sc2 (Injection-eitherIsDiffOrNot arg-1 e-4))) (case (vector-ref sc2 0) ((0) (let ((e-2 (vector-ref sc2 1))) (vector 0 (cons (vector 0 e-1) e-2)))) (else (let ((e-5 (vector-ref sc2 1))) (vector 1 (lambda (eta-0) (Injection-isDifSProp e-5 eta-0))))))))) (else (let ((e-5 (vector-ref sc1 1))) (let ((sc2 (DataC-45Nat-isLT e-3 arg-1))) (case (vector-ref sc2 0) ((0) (let ((e-1 (vector-ref sc2 1))) (let ((sc3 (Injection-eitherIsDiffOrNot arg-1 e-4))) (case (vector-ref sc3 0) ((0) (let ((e-2 (vector-ref sc3 1))) (vector 0 (cons (vector 1 e-1) e-2)))) (else (let ((e-6 (vector-ref sc3 1))) (vector 1 (lambda (eta-0) (Injection-isDifSProp e-6 eta-0))))))))) (else (let ((e-6 (vector-ref sc2 1))) (vector 1 (lambda (eta-0) (Injection-eitherVoidThenNotDif (lambda (eta-1) (Injection-eitherVoid e-5 e-6 eta-1)) eta-0))))))))))))))))
(define Injection-notAllDiffProp (lambda (arg-3 arg-4) (let ((e-3 (car arg-4))) (arg-3 e-3))))
(define Injection-eitherAllDiffOrNot (lambda (arg-1) (if (null? arg-1) (vector 0 '()) (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((sc1 (Injection-eitherIsDiffOrNot e-3 e-4))) (case (vector-ref sc1 0) ((0) (let ((e-2 (vector-ref sc1 1))) (let ((sc2 (Injection-eitherAllDiffOrNot e-4))) (case (vector-ref sc2 0) ((0) (let ((e-5 (vector-ref sc2 1))) (vector 0 (cons e-2 e-5)))) (else (let ((e-5 (vector-ref sc2 1))) (vector 1 (lambda (eta-0) (Injection-allDifSProp e-5 eta-0))))))))) (else (let ((e-5 (vector-ref sc1 1))) (vector 1 (lambda (eta-0) (Injection-notAllDiffProp e-5 eta-0))))))))))))
(define Injection-allSmallSProp (lambda (arg-4 arg-5) (let ((e-5 (cdr arg-5))) (arg-4 e-5))))
(define Injection-notSmallerProp (lambda (arg-4 arg-5) (let ((e-4 (car arg-5))) (arg-4 e-4))))
(define Injection-eitherAllSmallerOrNot (lambda (arg-1 arg-2) (if (null? arg-2) (vector 0 '()) (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((sc1 (DataC-45Nat-isLT e-3 arg-1))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (let ((sc2 (Injection-eitherAllSmallerOrNot arg-1 e-4))) (case (vector-ref sc2 0) ((0) (let ((e-2 (vector-ref sc2 1))) (vector 0 (cons e-1 e-2)))) (else (let ((e-5 (vector-ref sc2 1))) (vector 1 (lambda (eta-0) (Injection-allSmallSProp e-5 eta-0))))))))) (else (let ((e-5 (vector-ref sc1 1))) (vector 1 (lambda (eta-0) (Injection-notSmallerProp e-5 eta-0))))))))))))
(define Injection-notInjIfNotDifProp (lambda (arg-3 arg-4) (let ((e-3 (car arg-4))) (arg-3 e-3))))
(define Injection-notInjIfNotSmallProp (lambda (arg-3 arg-4) (let ((e-4 (cdr arg-4))) (arg-3 e-4))))
(define Injection-eitherIsInjectiveTOrNot (lambda (arg-1 arg-2) (let ((sc0 (Injection-eitherAllDiffOrNot arg-2))) (case (vector-ref sc0 0) ((0) (let ((e-2 (vector-ref sc0 1))) (let ((sc1 (Injection-eitherAllSmallerOrNot arg-1 arg-2))) (case (vector-ref sc1 0) ((0) (let ((e-3 (vector-ref sc1 1))) (vector 0 (cons e-2 e-3)))) (else (let ((e-5 (vector-ref sc1 1))) (vector 1 (lambda (eta-0) (Injection-notInjIfNotSmallProp e-5 eta-0))))))))) (else (let ((e-5 (vector-ref sc0 1))) (vector 1 (lambda (eta-0) (Injection-notInjIfNotDifProp e-5 eta-0)))))))))
(define Injection-decInj (lambda (arg-1 arg-2) (let ((sc0 (Injection-eitherIsInjectiveTOrNot arg-1 arg-2))) (case (vector-ref sc0 0) ((0) (let ((e-2 (vector-ref sc0 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref sc0 1))) (vector 1 e-5)))))))
(define PreludeC-45Uninhabited-void (lambda (ext-0) (display "Error: Executed 'void'")))
(define PreludeC-45Uninhabited-absurd (lambda (arg-2 arg-3) (PreludeC-45Uninhabited-void 'erased)))
(define Injection-allDiffToPrf (lambda (arg-3) (let ((e-3 (car arg-3))) e-3)))
(define Injection-ifDiffThenSubDiff (lambda (arg-4) (let ((e-5 (cdr arg-4))) e-5)))
(define Injection-isDiffToPrf (lambda (arg-4) (let ((e-4 (car arg-4))) e-4)))
(define Lemmas-differentC-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-2 0) (Injection-isDiffToPrf arg-5))(else (let ((e-0 (- arg-2 1))) (let ((e-8 (cdr arg-3))) (Lemmas-differentC-39 arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4) (Injection-ifDiffThenSubDiff arg-5))))))))
(define Lemmas-mirror (lambda (arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 1 e-2))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 0 e-5))))))
(define Lemmas-differentC-39C-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-2 0) (Lemmas-mirror (Injection-isDiffToPrf arg-5)))(else (let ((e-0 (- arg-2 1))) (let ((e-8 (cdr arg-3))) (Lemmas-differentC-39C-39 arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4) (Injection-ifDiffThenSubDiff arg-5))))))))
(define Lemmas-eitherLTSucc (lambda (arg-0 arg-1 arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 0 (DataC-45Nat-fromLteSucc e-2)))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 1 (DataC-45Nat-fromLteSucc e-5)))))))
(define Injection-getAllDifferent (lambda (arg-3) (let ((e-3 (car arg-3))) e-3)))
(define Injection-ifAllDiffThenSubDiff (lambda (arg-3) (let ((e-4 (cdr arg-3))) e-4)))
(define Injection-ifAllSmallThenSubSmall (lambda (arg-4) (let ((e-5 (cdr arg-4))) e-5)))
(define Injection-ifInjectiveThenSubInjective (lambda (arg-4) (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (cons (Injection-ifAllDiffThenSubDiff e-3) (Injection-ifAllSmallThenSubSmall e-4))))))
(define PreludeC-45Types-u--uninhabited_Uninhabited_C-40C-40EitherC-32C-36aC-41C-32C-36bC-41 (lambda (arg-2 arg-3 arg-4) (case (vector-ref arg-4 0) ((0) (let ((e-2 (vector-ref arg-4 1))) (arg-2 e-2))) (else (let ((e-5 (vector-ref arg-4 1))) (arg-3 e-5))))))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define Lemmas-differentIndexInjectiveVect (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (PreludeC-45Uninhabited-absurd (lambda (eta-0) (PreludeC-45Types-u--uninhabited_Uninhabited_C-40C-40EitherC-32C-36aC-41C-32C-36bC-41 (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 eta-1)) (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 eta-1)) eta-0)) arg-4))(else (let ((e-1 (- arg-2 1))) (let ((e-4 (car arg-5))) (let ((e-5 (cdr arg-5))) (Lemmas-differentC-39 e-4 e-1 e-5 (DataC-45Nat-fromLteSucc arg-8) (Injection-allDiffToPrf (Injection-getAllDifferent arg-6)))))))))(else (let ((e-0 (- arg-1 1))) (cond ((equal? arg-2 0) (let ((e-9 (car arg-5))) (let ((e-10 (cdr arg-5))) (Lemmas-differentC-39C-39 e-9 e-0 e-10 (DataC-45Nat-fromLteSucc arg-7) (Injection-allDiffToPrf (Injection-getAllDifferent arg-6))))))(else (let ((e-6 (- arg-2 1))) (let ((e-14 (cdr arg-5))) (Lemmas-differentIndexInjectiveVect e-0 e-6 arg-3 (Lemmas-eitherLTSucc e-0 e-6 arg-4) e-14 (Injection-ifInjectiveThenSubInjective arg-6) (DataC-45Nat-fromLteSucc arg-7) (DataC-45Nat-fromLteSucc arg-8)))))))))))
(define Injection-getAllSmaller (lambda (arg-3) (let ((e-4 (cdr arg-3))) e-4)))
(define Injection-getPrfSmaller (lambda (arg-3) (let ((e-4 (car arg-3))) e-4)))
(define Lemmas-indexInjectiveVect (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-1 0) (Injection-getPrfSmaller (Injection-getAllSmaller arg-4)))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-3))) (Lemmas-indexInjectiveVect e-0 arg-2 e-8 (Injection-ifInjectiveThenSubInjective arg-4) (DataC-45Nat-fromLteSucc arg-5))))))))
(define UnitaryLinear-apply (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (case (vector-ref arg-2 0) ((0) arg-3) ((1) (let ((e-2 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 2))) (let ((e-4 (vector-ref arg-2 3))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect e-2 arg-1 arg-4 arg-5 eta-0)))) (vector 1 (Injection-indexLT e-2 arg-4 e-3) (u--prf1 e-3) (UnitaryLinear-apply arg-0 arg-1 e-4 arg-3 arg-4 arg-5))))))) ((2) (let ((e-6 (vector-ref arg-2 1))) (let ((e-7 (vector-ref arg-2 2))) (let ((e-8 (vector-ref arg-2 3))) (let ((e-9 (vector-ref arg-2 4))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect e-7 arg-1 arg-4 arg-5 eta-0)))) (vector 2 e-6 (Injection-indexLT e-7 arg-4 e-8) (u--prf1 e-8) (UnitaryLinear-apply arg-0 arg-1 e-9 arg-3 arg-4 arg-5)))))))) (else (let ((e-11 (vector-ref arg-2 1))) (let ((e-12 (vector-ref arg-2 2))) (let ((e-13 (vector-ref arg-2 3))) (let ((e-14 (vector-ref arg-2 4))) (let ((e-15 (vector-ref arg-2 5))) (let ((e-16 (vector-ref arg-2 6))) (let ((u--prf4 (lambda (eta-0) (Lemmas-indexInjectiveVect e-11 arg-1 arg-4 arg-5 eta-0)))) (let ((u--prf5 (lambda (eta-0) (Lemmas-indexInjectiveVect e-12 arg-1 arg-4 arg-5 eta-0)))) (let ((u--prf6 (Lemmas-differentIndexInjectiveVect e-11 e-12 arg-1 e-15 arg-4 arg-5 e-13 e-14))) (vector 3 (Injection-indexLT e-11 arg-4 e-13) (Injection-indexLT e-12 arg-4 e-14) (u--prf4 e-13) (u--prf5 e-14) u--prf6 (UnitaryLinear-apply arg-0 arg-1 e-16 arg-3 arg-4 arg-5)))))))))))))))
(define PreludeC-45Show-n--3221-12652-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define DataC-45Vect-foldrImpl (lambda (arg-3 arg-4 arg-5 arg-6) (if (null? arg-6) (arg-5 arg-4) (let ((e-3 (car arg-6))) (let ((e-4 (cdr arg-6))) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) (arg-5 ((arg-3 e-3) eta-0))) e-4))))))
(define DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4 arg-5) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) eta-0) arg-5)))
(define DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 (lambda (ext-0) (DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 csegen-118 '() ext-0)))
(define DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 (lambda (arg-2 ext-0) (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 arg-2 (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 ext-0))))
(define UnitaryLinear-case--applyOrErrorIO-7913 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7) (case (vector-ref arg-7 0) ((0) (let ((e-1 (vector-ref arg-7 1))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect arg-2 arg-1 arg-5 e-1 eta-0)))) (cons (vector 1 (Injection-indexLT arg-2 arg-5 arg-3) (u--prf1 arg-3) (UnitaryLinear-apply arg-0 arg-1 arg-4 arg-6 arg-5 e-1)) (lambda (eta-0) (vector 0 )))))) (else (cons arg-6 (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Application at " (string-append (DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 csegen-123 arg-5) " not possible.")) "\xa;") world-0))) (vector 0 ))))))))
(define UnitaryLinear-case--applyOrErrorIO-8040 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8) (case (vector-ref arg-8 0) ((0) (let ((e-1 (vector-ref arg-8 1))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect arg-2 arg-1 arg-6 e-1 eta-0)))) (cons (vector 2 arg-5 (Injection-indexLT arg-2 arg-6 arg-3) (u--prf1 arg-3) (UnitaryLinear-apply arg-0 arg-1 arg-4 arg-7 arg-6 e-1)) (lambda (eta-0) (vector 0 )))))) (else (cons arg-7 (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Application at " (string-append (DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 csegen-123 arg-6) " not possible.")) "\xa;") world-0))) (vector 0 ))))))))
(define UnitaryLinear-case--applyOrErrorIO-8167 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9 arg-10) (case (vector-ref arg-10 0) ((0) (let ((e-1 (vector-ref arg-10 1))) (let ((u--prf4 (lambda (eta-0) (Lemmas-indexInjectiveVect arg-3 arg-8 arg-7 e-1 eta-0)))) (let ((u--prf5 (lambda (eta-0) (Lemmas-indexInjectiveVect arg-2 arg-8 arg-7 e-1 eta-0)))) (let ((u--prf6 (Lemmas-differentIndexInjectiveVect arg-3 arg-2 arg-8 arg-4 arg-7 e-1 arg-6 arg-5))) (cons (vector 3 (Injection-indexLT arg-3 arg-7 arg-6) (Injection-indexLT arg-2 arg-7 arg-5) (u--prf4 arg-6) (u--prf5 arg-5) u--prf6 (UnitaryLinear-apply arg-0 arg-8 arg-1 arg-9 arg-7 e-1)) (lambda (eta-0) (vector 0 )))))))) (else (cons arg-9 (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Application at " (string-append (DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 csegen-123 arg-7) " not possible.")) "\xa;") world-0))) (vector 0 ))))))))
(define UnitaryLinear-applyOrErrorIO (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (case (vector-ref arg-2 0) ((0) (cons arg-3 (lambda (eta-0) (vector 0 )))) ((1) (let ((e-2 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 2))) (let ((e-4 (vector-ref arg-2 3))) (UnitaryLinear-case--applyOrErrorIO-7913 arg-0 arg-1 e-2 e-3 e-4 arg-4 arg-3 (Injection-decInj arg-1 arg-4)))))) ((2) (let ((e-6 (vector-ref arg-2 1))) (let ((e-7 (vector-ref arg-2 2))) (let ((e-8 (vector-ref arg-2 3))) (let ((e-9 (vector-ref arg-2 4))) (UnitaryLinear-case--applyOrErrorIO-8040 arg-0 arg-1 e-7 e-8 e-9 e-6 arg-4 arg-3 (Injection-decInj arg-1 arg-4))))))) (else (let ((e-11 (vector-ref arg-2 1))) (let ((e-12 (vector-ref arg-2 2))) (let ((e-13 (vector-ref arg-2 3))) (let ((e-14 (vector-ref arg-2 4))) (let ((e-15 (vector-ref arg-2 5))) (let ((e-16 (vector-ref arg-2 6))) (UnitaryLinear-case--applyOrErrorIO-8167 arg-0 e-16 e-12 e-11 e-15 e-14 e-13 arg-4 arg-1 arg-3 (Injection-decInj arg-1 arg-4))))))))))))
(define SimulatedOp-case--applyUnitaryC-39-1766 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (let ((sc1 (UnitaryLinear-applyOrErrorIO arg-5 arg-1 arg-6 arg-3 e-3))) (let ((e-5 (car sc1))) (cons (vector arg-1 arg-4 e-5 arg-2 arg-0) e-2)))))))
(define SimulatedOp-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (SimulatedOp-case--applyUnitaryC-39-1766 e-4 arg-0 e-3 e-2 e-1 arg-1 arg-3 (QuantumOp-distributeDupedLVectVect arg-2))))))))
(define SimulatedOp-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (SimulatedOp-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define SimulatedOp-u--applyUnitary_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (SimulatedOp-applyUnitarySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define SimulatedOp-u--applyCNOT_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (SimulatedOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 2 (cons arg-1 (cons arg-2 '())) UnitaryLinear-CNOTGate eta-0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-0) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons clam-0 (cons e-2 (cons e-6 '()))))))))) ext-0)))
(define QuantumOp-qubitToNatPair (lambda (arg-0) (cons arg-0 arg-0)))
(define PreludeC-45Basics-irrelevantEq (vector 0 ))
(define DecidableC-45EqualityC-45Core-decEqCong (lambda (arg-6) (case (vector-ref arg-6 0) ((0) (vector 0 (vector 0 ))) (else (let ((e-3 (vector-ref arg-6 1))) (vector 1 (lambda (u--c) (e-3 PreludeC-45Basics-irrelevantEq))))))))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-124C-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-124C-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DecidableC-45Equality-u--decEq_DecEq_Nat (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (vector 0 (vector 0 )))(else (vector 1 (lambda (eta-0) (PreludeC-45Uninhabited-absurd (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-124C-41 eta-1)) eta-0))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (vector 1 (lambda (eta-0) (PreludeC-45Uninhabited-absurd (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-124C-41 eta-1)) eta-0))))(else (let ((e-2 (- arg-1 1))) (DecidableC-45EqualityC-45Core-decEqCong (DecidableC-45Equality-u--decEq_DecEq_Nat e-0 e-2))))))))))
(define QuantumOp-findInLinQ (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (if (null? arg-2) (let ((e-4 (cdr arg-2))) e-4) '()))(else (let ((e-5 (- arg-0 1))) (if (null? arg-2) (let ((e-4 (cdr arg-2))) e-4) (let ((e-15 (car arg-2))) (let ((e-16 (cdr arg-2))) (let ((sc1 (DecidableC-45Equality-u--decEq_DecEq_Nat arg-1 e-15))) (case (vector-ref sc1 0) ((0) e-16) (else (cons e-15 (QuantumOp-findInLinQ e-5 arg-1 e-16)))))))))))))
(define UnitaryLinear-SAdj (lambda (arg-1 arg-2 arg-3) (vector 2 (/ (- 3.141592653589793) 2.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-SAdjGate (UnitaryLinear-SAdj 0 1 (vector 0 )))
(define UnitaryLinear-TAdj (lambda (arg-1 arg-2 arg-3) (vector 2 (/ (- 3.141592653589793) 4.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-TAdjGate (UnitaryLinear-TAdj 0 1 (vector 0 )))
(define UnitaryLinear-T (lambda (arg-1 arg-2 arg-3) (vector 2 (/ 3.141592653589793 4.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-TGate (UnitaryLinear-T 0 1 (vector 0 )))
(define Lemmas-eitherLTtoSucc (lambda (arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 0 (+ e-2 1)))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 1 (+ e-5 1)))))))
(define Lemmas-ltzs (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-ltzs e-0))))))
(define Lemmas-lemmaDiffSuccPlusE (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 (Lemmas-ltzs arg-1)))(else (let ((e-0 (- arg-0 1))) (Lemmas-eitherLTtoSucc (Lemmas-lemmaDiffSuccPlusE e-0 arg-1)))))))
(define Lemmas-isDiffRangeVect (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Lemmas-lemmaDiffSuccPlusE arg-0 arg-2) (Lemmas-isDiffRangeVect arg-0 e-0 (+ arg-2 1))))))))
(define Lemmas-allDiffRangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (let ((u--p1 (Lemmas-isDiffRangeVect arg-0 e-0 0))) (cons u--p1 (Lemmas-allDiffRangeVect (+ arg-0 1) e-0))))))))
(define Injection-lteTransitive (lambda (arg-3 arg-4) (cond ((equal? arg-3 0) 0)(else (let ((e-3 (- arg-3 1))) (cond ((equal? arg-4 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-6 (- arg-4 1))) (+ (Injection-lteTransitive e-3 e-6) 1)))))))))
(define Injection-plusLT (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) arg-3)(else (Injection-lteTransitive arg-3 arg-1)))))
(define Injection-ifAllSmallThenPlusSmall (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-1) (if (null? arg-4) '() (cond ((equal? arg-3 0) arg-4)(else (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-4 (- arg-3 1))) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (cons (Injection-plusLT e-2 arg-2 (+ e-4 1) e-9) (Injection-ifAllSmallThenPlusSmall e-3 arg-2 (+ e-4 1) e-10)))))))))))) (cond ((equal? arg-3 0) arg-4)(else (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-4 (- arg-3 1))) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (cons (Injection-plusLT e-2 arg-2 (+ e-4 1) e-9) (Injection-ifAllSmallThenPlusSmall e-3 arg-2 (+ e-4 1) e-10))))))))))))))
(define Lemmas-allSmallerPlus (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-3) '() (Injection-ifAllSmallThenPlusSmall arg-3 arg-1 arg-2 arg-4))))
(define Lemmas-lemmaLTSuccPlus (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else (let ((e-1 (- arg-1 1))) (DataC-45Nat-fromLteSucc (+ (Lemmas-lemmaLTSuccPlus 0 e-1) 1))))))(else (let ((e-0 (- arg-0 1))) (+ (Lemmas-lemmaLTSuccPlus e-0 arg-1) 1))))))
(define Lemmas-allSmallerRangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Lemmas-lemmaLTSuccPlus arg-0 e-0) (Lemmas-allSmallerRangeVect (+ arg-0 1) e-0)))))))
(define Lemmas-isInjectiveRangeVect (lambda (arg-0 arg-1) (cons (Lemmas-allDiffRangeVect arg-0 arg-1) (Lemmas-allSmallerRangeVect arg-0 arg-1))))
(define Injection-rangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons arg-0 (Injection-rangeVect (+ arg-0 1) e-0)))))))
(define UnitaryLinear-tensor (lambda (arg-0 arg-1 arg-2 arg-3) (let ((u--p1 (Lemmas-allSmallerRangeVect 0 arg-0))) (let ((u--p2 (Lemmas-isInjectiveRangeVect arg-0 arg-1))) (let ((u--p3 (Lemmas-allSmallerPlus arg-0 arg-1 (Injection-rangeVect 0 arg-0) u--p1))) (let ((u--p4 (cons (Lemmas-allDiffRangeVect 0 arg-0) u--p3))) (UnitaryLinear-apply arg-1 (+ arg-0 arg-1) arg-3 (UnitaryLinear-apply arg-0 (+ arg-0 arg-1) arg-2 (vector 0 ) (Injection-rangeVect 0 arg-0) u--p4) (Injection-rangeVect arg-0 arg-1) u--p2)))))))
(define UnitaryLinear-controlledH (lambda () (let ((u--h1 (UnitaryLinear-tensor 1 1 (vector 0 ) (UnitaryLinear-compose UnitaryLinear-SAdjGate (UnitaryLinear-compose UnitaryLinear-HGate (UnitaryLinear-compose UnitaryLinear-TGate csegen-127)))))) (let ((u--h2 (UnitaryLinear-tensor 1 1 (vector 0 ) (UnitaryLinear-compose UnitaryLinear-SAdjGate (UnitaryLinear-compose UnitaryLinear-HGate (UnitaryLinear-compose UnitaryLinear-TAdjGate csegen-127)))))) (UnitaryLinear-compose u--h1 (UnitaryLinear-compose UnitaryLinear-CNOTGate u--h2))))))
(define UnitaryLinear-controlledP (lambda (arg-0) (let ((u--p1 (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 2 (/ arg-0 2.0) 1 2 (vector 0 ))))) (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 2 (/ (- arg-0) 2.0) 1 2 u--p1)))))
(define Lemmas-ltzss (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-ltzss e-0))))))
(define Lemmas-lemmaControlledInj (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-1)) '()) (cons '() '())) (cons Lemmas-ltz1 (cons (+ arg-2 1) '())))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cons (cons csegen-147 (cons '() '())) (cons (Lemmas-ltzss e-0) (cons (+ arg-2 1) '()))))(else (let ((e-2 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) '()) (cons '() '())) (cons (Lemmas-ltzss e-0) (cons (+ arg-2 1) '())))))))))))
(define Lemmas-lt1ss (lambda (arg-0) (cond ((equal? arg-0 0) 2)(else (let ((e-0 (- arg-0 1))) (Lemmas-lt1ss e-0))))))
(define Lemmas-lemmaControlledInj2 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-1)) (cons (vector 0 (Lemmas-ltzs arg-2)) '())) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons Lemmas-ltz1 (cons (+ arg-3 1) (cons (+ arg-4 1) '()))))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (cons (cons (cons (vector 0 Lemmas-ltz1) csegen-147) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))(else (let ((e-3 (- arg-2 1))) (cons (cons (cons (vector 0 Lemmas-ltz1) (cons (vector 0 (Lemmas-ltzss e-3)) '())) (cons (cons (vector 0 (Lemmas-lt1ss e-3)) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '()))))))))(else (let ((e-2 (- arg-1 1))) (cond ((equal? arg-2 0) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) csegen-147) (cons (cons (vector 1 (Lemmas-lt1ss e-2)) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))(else (let ((e-4 (- arg-2 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) (cons (vector 0 (Lemmas-ltzss e-4)) '())) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))))))))))))
(define UnitaryLinear-toffoli (let ((u--g1 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (vector 1 2 3 (vector 0 ))))) (let ((u--g2 (vector 3 0 2 (Lemmas-lemma1LTESucc 2) 3 (vector 0 (Lemmas-lemma1LTESucc 1)) (UnitaryLinear-TAdj 2 3 u--g1)))) (let ((u--g3 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (UnitaryLinear-T 2 3 u--g2)))) (let ((u--g4 (vector 3 0 2 (Lemmas-lemma1LTESucc 2) 3 (vector 0 (Lemmas-lemma1LTESucc 1)) (UnitaryLinear-TAdj 2 3 u--g3)))) (let ((u--g5 (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (UnitaryLinear-T 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 1 2 3 (UnitaryLinear-T 2 3 u--g4)))))) (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (UnitaryLinear-T 0 (Lemmas-lemma1LTESucc 2) (UnitaryLinear-TAdj 1 (+ (Lemmas-lemma1LTESucc 1) 1) u--g5)))))))))
(define UnitaryLinear-controlled (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (vector 0 )) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((u--p (Lemmas-lemmaControlledInj arg-0 e-2 e-3))) (UnitaryLinear-apply 2 (+ arg-0 1) (UnitaryLinear-controlledH) (UnitaryLinear-controlled arg-0 e-4) (cons 0 (cons (+ e-2 1) '())) u--p)))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((u--p1 (Lemmas-lemmaControlledInj arg-0 e-7 e-8))) (UnitaryLinear-apply 2 (+ arg-0 1) (UnitaryLinear-controlledP e-6) (UnitaryLinear-controlled arg-0 e-9) (cons 0 (cons (+ e-7 1) '())) u--p1))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (let ((u--p (Lemmas-lemmaControlledInj2 arg-0 e-11 e-12 e-13 e-14 e-15))) (UnitaryLinear-apply 3 (+ arg-0 1) UnitaryLinear-toffoli (UnitaryLinear-controlled arg-0 e-16) (cons 0 (cons (+ e-11 1) (cons (+ e-12 1) '()))) u--p))))))))))))
(define SimulatedOp-case--caseC-32blockC-32inC-32applyControlledUSplitSimC-39-2832 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-9 arg-10 arg-11 arg-12) (let ((e-2 (car arg-12))) (let ((e-3 (cdr arg-12))) (let ((e-6 (vector-ref e-2 2))) (let ((e-7 (vector-ref e-2 3))) (let ((e-11 (car e-3))) (let ((e-12 (cdr e-3))) (let ((sc2 (UnitaryLinear-applyOrErrorIO (+ arg-2 1) (+ arg-2 1) (UnitaryLinear-controlled arg-2 e-6) arg-5 (cons arg-10 e-7)))) (let ((e-10 (car sc2))) (cons (vector (+ arg-2 1) arg-6 e-10 arg-4 arg-3) (cons (cons arg-9 e-11) e-12))))))))))))
(define SimulatedOp-case--applyControlledUSplitSimC-39-2793 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-9) (let ((e-2 (car arg-9))) (let ((e-3 (cdr arg-9))) (let ((u--vn (QuantumOp-findInLinQ arg-2 e-2 arg-4))) (SimulatedOp-case--caseC-32blockC-32inC-32applyControlledUSplitSimC-39-2832 arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 e-2 e-3 u--vn (arg-7 (vector arg-2 (Matrix-neutralIdPow arg-2) (vector 0 ) u--vn arg-2))))))))
(define SimulatedOp-applyControlledUSplitSimC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-0 (vector-ref arg-5 0))) (let ((e-1 (vector-ref arg-5 1))) (let ((e-2 (vector-ref arg-5 2))) (let ((e-3 (vector-ref arg-5 3))) (let ((e-4 (vector-ref arg-5 4))) (cond ((equal? e-0 0) (blodwen-error-quit "Nat case not covered"))(else (SimulatedOp-case--applyControlledUSplitSimC-39-2793 arg-0 arg-1 arg-2 e-4 e-3 e-2 e-1 arg-4 (QuantumOp-qubitToNatPair arg-3)))))))))))
(define SimulatedOp-applyControlledSimulatedSplit (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (SimulatedOp-applyControlledUSplitSimC-39 arg-0 arg-1 arg-2 arg-3 arg-4 ext-0)))
(define SimulatedOp-u--applyControlWithSplitLVects_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-2 ext-1 ext-0) (SimulatedOp-applyControlledSimulatedSplit arg-0 arg-1 arg-2 ext-2 ext-1 ext-0)))
(define SimulatedOp-case--caseC-32blockC-32inC-32applyControlSimulatedC-39-2374 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-8 arg-9 arg-10 arg-11) (let ((e-2 (car arg-11))) (let ((e-3 (cdr arg-11))) (let ((e-6 (vector-ref e-2 2))) (let ((e-7 (vector-ref e-2 3))) (let ((sc1 (UnitaryLinear-applyOrErrorIO (+ arg-2 1) (+ arg-2 1) (UnitaryLinear-controlled arg-2 e-6) arg-4 (cons arg-9 e-7)))) (let ((e-10 (car sc1))) (cons (vector (+ arg-2 1) arg-5 e-10 arg-3 arg-1) (cons arg-8 e-3))))))))))
(define SimulatedOp-case--applyControlSimulatedC-39-2337 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (let ((u--vn (QuantumOp-findInLinQ arg-2 e-2 arg-3))) (SimulatedOp-case--caseC-32blockC-32inC-32applyControlSimulatedC-39-2374 arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 e-2 e-3 u--vn (arg-6 (vector arg-2 (Matrix-neutralIdPow arg-2) (vector 0 ) u--vn arg-2))))))))
(define SimulatedOp-applyControlSimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-0 (vector-ref arg-4 0))) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (cond ((equal? e-0 0) (blodwen-error-quit "Nat case not covered"))(else (SimulatedOp-case--applyControlSimulatedC-39-2337 arg-1 e-4 arg-0 e-3 e-2 e-1 arg-3 (QuantumOp-qubitToNatPair arg-2)))))))))))
(define SimulatedOp-applyControlAbsSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (SimulatedOp-applyControlSimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define SimulatedOp-u--applyControlledAbs_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (SimulatedOp-applyControlAbsSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define QuantumOp-u--applyHQ_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp arg-1 1 (let ((e-3 (vector-ref arg-0 2))) ((e-3 arg-1) arg-2)) eta-0)) csegen-87 ext-0)))
(define SimulatedOp-u--applyH_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (SimulatedOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 1 (cons arg-1 '()) UnitaryLinear-HGate eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define QuantumOp-u--applyPQ_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp arg-1 1 (let ((e-4 (vector-ref arg-0 3))) (((e-4 arg-1) arg-2) arg-3)) eta-0)) csegen-87 ext-0)))
(define UnitaryLinear-PGate (lambda (arg-0) (vector 2 arg-0 0 1 (vector 0 ))))
(define SimulatedOp-u--applyP_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (SimulatedOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 1 (cons arg-2 '()) (UnitaryLinear-PGate arg-1) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define LinearTypes-C-43C-43 (lambda (arg-3 arg-4) (if (null? arg-3) arg-4 (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons e-3 (LinearTypes-C-43C-43 e-4 arg-4)))))))
(define SimulatedOp-applyParallelSimulatedC-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-1 (vector-ref arg-5 1))) (let ((e-2 (vector-ref arg-5 2))) (let ((e-3 (vector-ref arg-5 3))) (let ((e-4 (vector-ref arg-5 4))) (let ((sc0 (arg-3 (vector arg-1 e-1 (vector 0 ) e-3 e-4)))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-9 (vector-ref e-6 2))) (let ((sc1 (arg-4 (vector arg-1 e-1 (vector 0 ) e-3 e-4)))) (let ((e-13 (car sc1))) (let ((e-12 (cdr sc1))) (let ((e-16 (vector-ref e-13 2))) (let ((e-15 (vector-ref e-13 3))) (let ((u--unewest (UnitaryLinear-compose e-9 e-2))) (let ((u--uOut (UnitaryLinear-compose e-16 u--unewest))) (cons (vector arg-1 e-1 u--uOut e-15 e-4) (LinearTypes-C-43C-43 e-5 e-12)))))))))))))))))))
(define SimulatedOp-applyParallelSimulated (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (SimulatedOp-applyParallelSimulatedC-39 arg-0 arg-1 arg-3 arg-4 ext-0)))
(define SimulatedOp-u--applyParallel_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-2 ext-1 ext-0) (SimulatedOp-applyParallelSimulated arg-0 arg-1 arg-2 ext-2 ext-1 ext-0)))
(define QuantumOp-case--applyUDirectlySimulatedC-39-15432 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-7 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (let ((sc1 (UnitaryLinear-applyOrErrorIO arg-1 arg-0 arg-7 (vector 0 ) e-3))) (let ((e-5 (car sc1))) (let ((u--qs2 (QuantumOp-applyCirc arg-0 arg-3 e-5 (vector arg-0 arg-5 arg-4 arg-3 arg-2)))) (vector 1 (cons u--qs2 e-2)))))))))
(define QuantumOp-applyUDirectlySimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (QuantumOp-case--applyUDirectlySimulatedC-39-15432 arg-0 arg-1 e-4 e-3 e-2 e-1 arg-2 (QuantumOp-distributeDupedLVectVect arg-3))))))))
(define QuantumOp-applyUDirectlySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (QuantumOp-applyUDirectlySimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define QuantumOp-u--applyUnitaryDirectly_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (QuantumOp-applyUDirectlySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define SimulatedOp-case--applyUnitaryOwnC-39-1884 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9 arg-11) (let ((e-2 (car arg-11))) (let ((e-3 (cdr arg-11))) (let ((sc1 (UnitaryLinear-applyOrErrorIO arg-1 arg-6 arg-3 arg-8 e-3))) (let ((e-5 (car sc1))) (cons (vector arg-6 arg-9 e-5 arg-7 arg-5) e-2)))))))
(define SimulatedOp-applyUnitaryOwnC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-2 1))) (let ((e-2 (vector-ref arg-2 2))) (let ((e-3 (vector-ref arg-2 3))) (let ((e-4 (vector-ref arg-2 4))) (let ((e-6 (vector-ref arg-4 1))) (let ((e-7 (vector-ref arg-4 2))) (let ((e-8 (vector-ref arg-4 3))) (let ((e-9 (vector-ref arg-4 4))) (SimulatedOp-case--applyUnitaryOwnC-39-1884 e-4 arg-1 e-3 e-2 e-1 e-9 arg-0 e-8 e-7 e-6 (QuantumOp-distributeDupedLVectVect arg-3))))))))))))
(define SimulatedOp-applyUnitaryOwnSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (SimulatedOp-applyUnitaryOwnC-39 arg-0 arg-1 arg-3 arg-2 ext-0)))
(define SimulatedOp-u--applyUnitaryOwn_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (SimulatedOp-applyUnitaryOwnSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define SimulatedOp-exportSelfC-39 (lambda (arg-1 arg-2 arg-3) (let ((sc0 (arg-3 arg-2))) (let ((e-2 (car sc0))) e-2))))
(define SimulatedOp-u--exportSelf_UnitaryOp_SimulatedOp (lambda (arg-1 ext-0 ext-1) (SimulatedOp-exportSelfC-39 arg-1 ext-0 ext-1)))
(define LinearTypes-consLin (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) (cons 0 '()) (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (cons 0 (cons e-3 e-4)))))) (else (if (null? arg-2) (cons 1 '()) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (cons 1 (cons e-8 e-9)))))))))
(define QuantumOp-listIndexC-39 (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) 0)(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (let ((sc1 (or (and (= e-4 arg-2) 1) 0))) (cond ((equal? sc1 1) 0) (else (+ (QuantumOp-listIndexC-39 e-0 e-5 arg-2) 1)))))))))))
(define QuantumOp-case--listIndex-15013 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-6) (let ((e-2 (car arg-6))) (cons (cons (vector arg-0 arg-4 arg-3 arg-2 arg-1) e-2) (QuantumOp-listIndexC-39 arg-0 arg-2 e-2)))))
(define QuantumOp-listIndex (lambda (arg-1 arg-2) (let ((e-0 (vector-ref arg-1 0))) (let ((e-1 (vector-ref arg-1 1))) (let ((e-2 (vector-ref arg-1 2))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (QuantumOp-case--listIndex-15013 e-0 e-4 e-3 e-2 e-1 (QuantumOp-qubitToNatPair arg-2)))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Matrix-inv (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Double arg-0 0.0))) (cond ((equal? sc0 1) 0.0) (else (/ 1.0 arg-0))))))
(define Complex-magnitude (lambda (arg-0) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (flsqrt (+ (* e-1 e-1) (* e-2 e-2)))))))
(define Matrix-normState2 (lambda (arg-1) (if (null? arg-1) 0.0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (let ((u--m (Complex-magnitude e-7))) (+ (* u--m u--m) (Matrix-normState2 e-4))))))))))
(define DataC-45Vect-with--splitAt-5632 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (cons (cons arg-5 e-2) e-3)))))
(define DataC-45Vect-splitAt (lambda (arg-2 arg-3) (cond ((equal? arg-2 0) (cons '() arg-3))(else (let ((e-0 (- arg-2 1))) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (DataC-45Vect-with--splitAt-5632 'erased 'erased e-0 e-4 (DataC-45Vect-splitAt e-0 e-4) e-3))))))))
(define Matrix-projectState (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) (let ((sc1 (DataC-45Vect-splitAt (DataC-45Nat-power 2 arg-0) arg-1))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cond ((equal? arg-3 1) e-3) (else e-2))))))(else (cond ((equal? arg-0 0) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else csegen-93)))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-2 (- arg-2 1))) (let ((sc0 (DataC-45Vect-splitAt (DataC-45Nat-power 2 (+ e-0 1)) arg-1))) (let ((e-4 (car sc0))) (let ((e-3 (cdr sc0))) (let ((u--v1C-39 (Matrix-projectState e-0 e-4 e-2 arg-3))) (let ((u--v2C-39 (Matrix-projectState e-0 e-3 e-2 arg-3))) (DataC-45Vect-C-43C-43 u--v1C-39 u--v2C-39))))))))))))))))
(define QuantumOp-removeElem (lambda (arg-0 arg-1 arg-2) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-2 0) e-3)(else (let ((e-4 (- arg-2 1))) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons e-2 (QuantumOp-removeElem e-0 e-3 e-4))))))))))))
(define PreludeC-45EqOrd-u--C-60_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Builtin-snd (lambda (arg-2) (let ((e-3 (cdr arg-2))) e-3)))
(define ControlC-45LinearC-45LIO-u--liftIO1_HasLinearIO_C-40LC-32C-36ioC-41 (lambda (arg-2 arg-3) (vector 3 (let ((sc0 (Builtin-snd arg-2))) (let ((e-2 (cdr sc0))) ((e-2 'erased) arg-3))))))
(define SystemC-45Random-randomDouble (lambda (ext-0) (SystemC-45Random-prim__randomDouble ext-0)))
(define SystemC-45Random-u--randomIO_Random_Double (lambda (arg-1) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45Random-randomDouble eta-0))))))
(define QuantumOp-measureC-39 (lambda (arg-0 arg-1 arg-2) (let ((e-0 (vector-ref arg-2 0))) (let ((e-1 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 3))) (let ((e-4 (vector-ref arg-2 4))) (cond ((equal? e-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((u--projector0 (Matrix-simpleTensor Matrix-matrixKet0Bra0 (+ arg-0 1) arg-1))) (let ((u--projection0 (Matrix-matrixMult (DataC-45Nat-power 2 (+ arg-0 1)) (DataC-45Nat-power 2 (+ arg-0 1)) 1 u--projector0 e-1))) (let ((u--norm20 (Matrix-normState2 u--projection0))) (let ((u--projector1 (Matrix-simpleTensor Matrix-matrixKet1Bra1 (+ arg-0 1) arg-1))) (let ((u--projection1 (Matrix-matrixMult (DataC-45Nat-power 2 (+ arg-0 1)) (DataC-45Nat-power 2 (+ arg-0 1)) 1 u--projector1 e-1))) (let ((u--norm21 (Matrix-normState2 u--projection1))) (let ((u--newQubits (QuantumOp-removeElem arg-0 e-3 arg-1))) (vector 4 2 (ControlC-45LinearC-45LIO-u--liftIO1_HasLinearIO_C-40LC-32C-36ioC-41 (cons csegen-91 (cons csegen-112 (lambda (u--a) (lambda (arg-13157) arg-13157)))) (SystemC-45Random-u--randomIO_Random_Double csegen-115)) (lambda (u--randnb) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Double u--randnb u--norm20))) (cond ((equal? sc0 1) (let ((u--proj (Matrix-multScalarMatrix (cons (Matrix-inv (flsqrt u--norm20)) 0.0) u--projection0))) (vector 1 (cons (vector arg-0 (Matrix-projectState arg-0 u--proj arg-1 0) (vector 0 ) u--newQubits e-4) 0)))) (else (let ((u--proj (Matrix-multScalarMatrix (cons (Matrix-inv (flsqrt u--norm21)) 0.0) u--projection1))) (vector 1 (cons (vector arg-0 (Matrix-projectState arg-0 u--proj arg-1 1) (vector 0 ) u--newQubits e-4) 1)))))))))))))))))))))))
(define QuantumOp-measureQubitsC-39C-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (vector 1 (cons arg-3 '())))(else (let ((e-0 (- arg-1 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc1 (QuantumOp-listIndex arg-3 e-4))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (let ((e-6 (car e-2))) (let ((e-7 (cdr e-2))) (let ((sc3 (QuantumOp-qubitToNatPair e-7))) (vector 4 1 (QuantumOp-measureC-39 (+ e-0 arg-0) e-3 e-6) (lambda (_-0) (let ((e-11 (car _-0))) (let ((e-10 (cdr _-0))) (vector 4 1 (QuantumOp-measureQubitsC-39C-39 arg-0 e-0 e-5 e-11) (lambda (_-1) (let ((e-13 (car _-1))) (let ((e-12 (cdr _-1))) (cond ((equal? e-0 0) (vector 1 (cons e-13 (cons e-10 '()))))(else (let ((e-15 (car e-12))) (let ((e-14 (cdr e-12))) (vector 1 (cons e-13 (cons e-10 (cons e-15 e-14)))))))))))))))))))))))))))))
(define QuantumOp-smallestMissingC-39 (lambda (arg-1) (if (null? arg-1) 0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (cond ((equal? e-3 0) (if (null? e-4) 1 (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (let ((sc4 (DecidableC-45Equality-u--decEq_DecEq_Nat (+ e-3 1) e-7))) (case (vector-ref sc4 0) ((0) (QuantumOp-smallestMissingC-39 (cons e-7 e-8))) (else (+ e-3 1))))))))(else (let ((e-9 (- e-3 1))) (if (null? e-4) (+ (+ e-9 1) 1) (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (let ((sc3 (DecidableC-45Equality-u--decEq_DecEq_Nat (+ e-3 1) e-7))) (case (vector-ref sc3 0) ((0) (QuantumOp-smallestMissingC-39 (cons e-7 e-8))) (else (+ e-3 1)))))))))))))))
(define QuantumOp-smallestMissing (lambda (arg-1) (if (null? arg-1) 0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (cond ((equal? e-3 0) (if (null? e-4) 1 (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (cond ((equal? e-3 0) (let ((sc5 (DecidableC-45Equality-u--decEq_DecEq_Nat 1 e-7))) (case (vector-ref sc5 0) ((0) (QuantumOp-smallestMissingC-39 (cons e-7 e-8))) (else 1))))(else 0))))))(else (let ((e-9 (- e-3 1))) (if (null? e-4) (+ (+ e-9 1) 1) (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (cond ((equal? e-3 0) (let ((sc4 (DecidableC-45Equality-u--decEq_DecEq_Nat 1 e-7))) (case (vector-ref sc4 0) ((0) (QuantumOp-smallestMissingC-39 (cons e-7 e-8))) (else 1))))(else 0)))))))))))))
(define DataC-45NatC-45Views-with--half-2505 (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (let ((e-0 (vector-ref arg-1 1))) (vector 0 e-0)))(else (case (vector-ref arg-1 0) ((0) (let ((e-2 (vector-ref arg-1 1))) (vector 1 (+ e-2 1))))(else (let ((e-0 (vector-ref arg-1 1))) (vector 0 e-0))))))))
(define DataC-45NatC-45Views-half (lambda (arg-0) (cond ((equal? arg-0 0) (vector 1 0))(else (let ((e-0 (- arg-0 1))) (DataC-45NatC-45Views-with--half-2505 e-0 (DataC-45NatC-45Views-half e-0)))))))
(define DataC-45Vect-mergeBy (lambda (arg-3 arg-4 arg-5) (if (null? arg-4) arg-5 (if (null? arg-5) arg-4 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (let ((e-6 (car arg-5))) (let ((e-7 (cdr arg-5))) (let ((sc4 ((arg-3 e-2) e-6))) (cond ((equal? sc4 0) (cons e-2 (DataC-45Vect-mergeBy arg-3 e-3 (cons e-6 e-7))))(else (cons e-6 (DataC-45Vect-mergeBy arg-3 (cons e-2 e-3) e-7)))))))))))))
(define DataC-45VectC-45Sort-sortByMerge (lambda (arg-1 arg-2 arg-3 arg-4) (let ((sc0 (DataC-45Vect-splitAt arg-1 arg-4))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (DataC-45Vect-mergeBy arg-3 (DataC-45VectC-45Sort-sortBySplit arg-1 arg-3 e-2) (DataC-45VectC-45Sort-sortBySplit arg-2 arg-3 e-3)))))))
(define DataC-45VectC-45Sort-with--sortBySplit-2662 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (case (vector-ref arg-1 0) ((1) (let ((e-2 (vector-ref arg-1 1))) (DataC-45VectC-45Sort-sortByMerge e-2 e-2 arg-4 arg-3)))(else (cond ((equal? arg-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (vector-ref arg-1 1))) (DataC-45VectC-45Sort-sortByMerge (+ e-1 1) e-1 arg-4 arg-3))))))))
(define DataC-45VectC-45Sort-sortBySplit (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (if (null? arg-3) '() (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2)))(else (let ((e-0 (- arg-1 1))) (cond ((equal? e-0 0) (if (null? arg-3) (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (if (null? e-5) (cons e-4 '()) (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2))))))(else (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2))))))))
(define DataC-45VectC-45Sort-sortBy (lambda (arg-1 arg-2 arg-3) (DataC-45VectC-45Sort-sortBySplit arg-1 arg-2 arg-3)))
(define DataC-45VectC-45Sort-sort (lambda (arg-1 arg-2 ext-0) (DataC-45VectC-45Sort-sortBy arg-2 (lambda (eta-0) (lambda (eta-1) (let ((e-2 (vector-ref arg-1 1))) ((e-2 eta-0) eta-1)))) ext-0)))
(define QuantumOp-reCalculateCounter (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) 0)(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (QuantumOp-smallestMissing (DataC-45VectC-45Sort-sort csegen-106 (+ e-0 1) (cons e-4 e-5))))))))))
(define QuantumOp-measureQubitsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (vector 1 (cons arg-3 '())))(else (let ((e-0 (- arg-1 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc1 (QuantumOp-listIndex arg-3 e-4))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (let ((e-6 (car e-2))) (let ((e-7 (cdr e-2))) (let ((sc3 (QuantumOp-qubitToNatPair e-7))) (vector 4 1 (QuantumOp-measureC-39 (+ e-0 arg-0) e-3 e-6) (lambda (_-0) (let ((e-11 (car _-0))) (let ((e-10 (cdr _-0))) (vector 4 1 (QuantumOp-measureQubitsC-39C-39 arg-0 e-0 e-5 e-11) (lambda (_-1) (let ((e-13 (car _-1))) (let ((e-12 (cdr _-1))) (let ((e-17 (vector-ref e-13 1))) (let ((e-16 (vector-ref e-13 2))) (let ((e-15 (vector-ref e-13 3))) (cond ((equal? e-0 0) (vector 1 (cons (vector arg-0 e-17 e-16 e-15 (QuantumOp-reCalculateCounter arg-0 e-15)) (cons e-10 '()))))(else (let ((e-20 (car e-12))) (let ((e-19 (cdr e-12))) (vector 1 (cons (vector arg-0 e-17 e-16 e-15 (QuantumOp-reCalculateCounter arg-0 e-15)) (cons e-10 (cons e-20 e-19))))))))))))))))))))))))))))))))
(define QuantumOp-measureSimulated (lambda (arg-0 arg-1 arg-2 ext-0) (QuantumOp-measureQubitsC-39 arg-0 arg-1 arg-2 ext-0)))
(define QuantumOp-u--measure_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-1 ext-0) (QuantumOp-measureSimulated arg-0 arg-1 ext-1 ext-0)))
(define QuantumOp-u--measureQubit_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--measure_QuantumOp_SimulatedOp arg-0 1 (cons arg-1 '()) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (QStateT-pure e-2 clam-0))))) ext-0)))
(define QuantumOp-u--measureAll_QuantumOp_SimulatedOp (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (lambda (clam-0) (QStateT-pure '() clam-0)))(else (let ((e-0 (- arg-0 1))) (lambda (clam-1) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--measureQubit_QuantumOp_SimulatedOp e-0 e-4 eta-0)) (lambda (u--b) (lambda (eta-0) (QStateT-C-62C-62C-61 (QuantumOp-u--measureAll_QuantumOp_SimulatedOp e-0 e-5) (lambda (u--bs) (lambda (eta-1) (QStateT-pure (LinearTypes-consLin u--b u--bs) eta-1))) eta-0))) clam-1)))))))))
(define Matrix-ket0 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons csegen-165 (Matrix-ket0 e-0)))))))
(define QuantumOp-newQubitsPointers (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (cons '() (cons '() arg-2)))(else (let ((e-0 (- arg-1 1))) (let ((u--newcounter (QuantumOp-reCalculateCounter (+ arg-0 1) (cons arg-2 arg-3)))) (let ((sc0 (QuantumOp-newQubitsPointers (+ arg-0 1) e-0 u--newcounter (cons arg-2 arg-3)))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons (cons arg-2 e-2) (cons (cons arg-2 e-6) e-7)))))))))))))
(define Matrix-tensorProductVect (lambda (arg-2 arg-3) (Matrix-tensorProduct arg-2 arg-3)))
(define QuantumOp-n--12611-16406-u--newQubitsC-39 (lambda (arg-1 arg-3 arg-4) (let ((e-0 (vector-ref arg-4 0))) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (let ((u--sC-39 (Matrix-toTensorBasis (Matrix-ket0 arg-3)))) (let ((sc0 (QuantumOp-newQubitsPointers e-0 arg-3 e-4 e-3))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-8 (car e-5))) (let ((e-7 (cdr e-5))) (vector 1 (cons (vector (+ e-0 arg-3) (Matrix-tensorProductVect e-1 u--sC-39) (UnitaryLinear-tensor e-0 arg-3 e-2 (vector 0 )) (DataC-45Vect-C-43C-43 e-3 e-8) e-7) e-6)))))))))))))))
(define QuantumOp-newQubitsSimulated (lambda (arg-1 ext-0) (QuantumOp-n--12611-16406-u--newQubitsC-39 arg-1 arg-1 ext-0)))
(define QuantumOp-u--newQubits_QuantumOp_SimulatedOp (lambda (ext-1 ext-0) (QuantumOp-newQubitsSimulated ext-1 ext-0)))
(define QuantumOp-u--newQubit_QuantumOp_SimulatedOp (lambda (ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--newQubits_QuantumOp_SimulatedOp 1 eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (QStateT-pure e-2 clam-0))))) ext-0)))
(define SimulatedOp-reCombineAbsC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (let ((sc0 (arg-3 (vector arg-0 e-1 e-2 e-3 e-4)))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-8 (car e-5))) (let ((e-7 (cdr e-5))) (cons e-6 (LinearTypes-C-43C-43 e-8 e-7)))))))))))))
(define SimulatedOp-reCombineAbsSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (SimulatedOp-reCombineAbsC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define SimulatedOp-u--reCombineAbs_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-1 ext-0) (SimulatedOp-reCombineAbsSimulated arg-2 arg-0 arg-1 ext-1 ext-0)))
(define SimulatedOp-u--reCombine_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (cons ext-0 (LinearTypes-C-43C-43 arg-3 arg-4))))
(define ControlC-45LinearC-45LIO-runK (lambda (arg-3 arg-4 arg-5 arg-6) (cond ((equal? arg-3 0) (case (vector-ref arg-5 0) ((0) (arg-6 'erased)) ((3) (let ((e-13 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-13) (lambda (u--xC-39) (arg-6 'erased)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))) ((equal? arg-3 1) (case (vector-ref arg-5 0) ((1) (let ((e-16 (vector-ref arg-5 1))) (arg-6 e-16))) ((3) (let ((e-20 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-20) (lambda (u--xC-39) (arg-6 u--xC-39)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))) ((equal? arg-3 2) (case (vector-ref arg-5 0) ((2) (let ((e-23 (vector-ref arg-5 1))) (arg-6 e-23))) ((3) (let ((e-27 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-27) (lambda (u--xC-39) (arg-6 u--xC-39)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))))))))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))))
(define ControlC-45LinearC-45LIO-run (lambda (arg-2 arg-3 arg-4) (ControlC-45LinearC-45LIO-runK 2 arg-3 arg-4 (lambda (eta-0) (let ((e-2 (vector-ref arg-2 1))) ((e-2 'erased) eta-0))))))
(define ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 (lambda (arg-2 ext-0) (vector 2 ext-0)))
(define QuantumOp-runSimulated (lambda (arg-0 arg-1) (ControlC-45LinearC-45LIO-run csegen-38 csegen-91 (vector 4 1 (arg-1 (vector 0 csegen-93 (vector 0 ) '() 0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (let ((e-4 (vector-ref e-2 0))) (cond ((equal? e-4 0) (cond ((equal? arg-0 0) (ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 csegen-38 '()))(else (let ((e-10 (car e-3))) (let ((e-9 (cdr e-3))) (ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 csegen-38 (cons e-10 e-9)))))))(else (blodwen-error-quit "Nat case not covered")))))))))))
(define QuantumOp-u--runQ_QuantumOp_SimulatedOp (lambda (arg-0 ext-0) (QuantumOp-runSimulated arg-0 ext-0)))
(define SimulatedOp-u--run_UnitaryOp_SimulatedOp (lambda (arg-1 ext-0 ext-1) (ext-1 ext-0)))
(define PreludeC-45Types-u--traverse_Traversable_List (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) '())) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((e-4 (vector-ref arg-3 2))) ((((e-4 'erased) 'erased) (let ((e-6 (vector-ref arg-3 2))) ((((e-6 'erased) 'erased) (let ((e-10 (vector-ref arg-3 1))) ((e-10 'erased) csegen-118))) (arg-4 e-2)))) (PreludeC-45Types-u--traverse_Traversable_List arg-3 arg-4 e-3))))))))
(define Main-testCoins (lambda () (let ((u--f (lambda (eta-0) (CoinToss-coin (vector (lambda (u--n) (lambda (u--i) (lambda (arg-9803) (lambda (arg-9806) (lambda (eta-1) (SimulatedOp-u--applyUnitary_UnitaryOp_SimulatedOp u--n u--i arg-9803 arg-9806 eta-1)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9819) (lambda (u--ownUnitary) (lambda (eta-1) (SimulatedOp-u--applyUnitaryOwn_UnitaryOp_SimulatedOp u--n u--i arg-9819 u--ownUnitary eta-1)))))) (lambda (u--n) (lambda (arg-9832) (lambda (eta-1) (SimulatedOp-u--applyH_UnitaryOp_SimulatedOp u--n arg-9832 eta-1)))) (lambda (u--n) (lambda (arg-9844) (lambda (arg-9847) (lambda (eta-1) (SimulatedOp-u--applyP_UnitaryOp_SimulatedOp u--n arg-9844 arg-9847 eta-1))))) (lambda (u--n) (lambda (arg-9860) (lambda (arg-9863) (lambda (eta-1) (SimulatedOp-u--applyCNOT_UnitaryOp_SimulatedOp u--n arg-9860 arg-9863 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9878) (lambda (arg-9881) (lambda (eta-1) (SimulatedOp-u--applyControlledAbs_UnitaryOp_SimulatedOp u--n u--i arg-9878 arg-9881 eta-1)))))) (lambda (u--n) (lambda (u--i) (lambda (u--j) (lambda (arg-9899) (lambda (arg-9902) (lambda (eta-1) (SimulatedOp-u--applyParallel_UnitaryOp_SimulatedOp u--n u--i u--j arg-9899 arg-9902 eta-1))))))) (lambda (u--i) (lambda (u--n) (lambda (arg-9914) (lambda (eta-1) (SimulatedOp-u--adjointUST_UnitaryOp_SimulatedOp arg-9914 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9922) (lambda (arg-9925) (SimulatedOp-u--run_UnitaryOp_SimulatedOp u--i arg-9922 arg-9925))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9935) (lambda (arg-9938) (SimulatedOp-u--exportSelf_UnitaryOp_SimulatedOp u--i arg-9935 arg-9938))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9952) (lambda (arg-9955) (lambda (eta-1) (SimulatedOp-u--reCombine_UnitaryOp_SimulatedOp u--i u--j u--n arg-9952 arg-9955 eta-1))))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9973) (lambda (eta-1) (SimulatedOp-u--reCombineAbs_UnitaryOp_SimulatedOp u--i u--j u--n arg-9973 eta-1)))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9990) (lambda (arg-9993) (lambda (eta-1) (SimulatedOp-u--applyControlWithSplitLVects_UnitaryOp_SimulatedOp u--i u--j u--n arg-9990 arg-9993 eta-1)))))))) (vector (lambda (u--n) (lambda (u--p) (lambda (eta-1) (QuantumOp-u--newQubits_QuantumOp_SimulatedOp u--p eta-1)))) (lambda (u--n) (lambda (eta-1) (QuantumOp-u--newQubit_QuantumOp_SimulatedOp eta-1))) (lambda (u--n) (lambda (u--i) (lambda (arg-12093) (lambda (eta-1) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp u--n u--i arg-12093 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-12105) (lambda (arg-12108) (lambda (eta-1) (QuantumOp-u--applyUnitaryDirectly_QuantumOp_SimulatedOp u--n u--i arg-12105 arg-12108 eta-1)))))) (lambda (i_con-0) (lambda (u--n) (lambda (arg-12122) (lambda (eta-1) (QuantumOp-u--applyHQ_QuantumOp_SimulatedOp i_con-0 u--n arg-12122 eta-1))))) (lambda (i_con-0) (lambda (u--n) (lambda (u--d) (lambda (arg-12140) (lambda (eta-1) (QuantumOp-u--applyPQ_QuantumOp_SimulatedOp i_con-0 u--n u--d arg-12140 eta-1)))))) (lambda (i_con-0) (lambda (u--n) (lambda (arg-12157) (lambda (arg-12160) (lambda (eta-1) (QuantumOp-u--applyCNOTQ_QuantumOp_SimulatedOp i_con-0 u--n arg-12157 arg-12160 eta-1)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-12176) (lambda (eta-1) (QuantumOp-u--measure_QuantumOp_SimulatedOp u--n u--i arg-12176 eta-1))))) (lambda (u--n) (lambda (arg-12188) (lambda (eta-1) (QuantumOp-u--measureQubit_QuantumOp_SimulatedOp u--n arg-12188 eta-1)))) (lambda (u--n) (lambda (arg-12198) (QuantumOp-u--measureAll_QuantumOp_SimulatedOp u--n arg-12198))) (lambda (u--n) (lambda (arg-12210) (QuantumOp-u--runQ_QuantumOp_SimulatedOp u--n arg-12210)))) eta-0)))) (lambda (world-0) (let ((act-1 ((PreludeC-45Interfaces-sequence csegen-38 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8885) (PreludeC-45TypesC-45List-mapAppend '() u--func arg-8885))))) csegen-56 (lambda (u--b) (lambda (u--a) (lambda (f-0) (lambda (i_con-0) (lambda (arg-14093) (lambda (arg-14100) (PreludeC-45Types-u--traverse_Traversable_List i_con-0 arg-14093 arg-14100)))))))) (DataC-45List-replicateTR '() 1000 u--f)) world-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "Number of heads: " (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (PreludeC-45TypesC-45List-filterAppend '() (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Bool arg-0 1)) act-1)))) "\xa;") world-0))))))
(define UnitaryLinear-addSymbol (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) '() (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (let ((e-7 (car arg-4))) (let ((e-8 (cdr arg-4))) (cons (string-append e-7 e-3) (UnitaryLinear-addSymbol 0 1 (cons e-3 e-4) e-8))))))) (else (let ((e-11 (car arg-3))) (let ((e-12 (cdr arg-3))) (let ((e-15 (car arg-4))) (let ((e-16 (cdr arg-4))) (cons (string-append e-15 e-12) (UnitaryLinear-addSymbol 0 1 (cons e-11 e-12) e-16)))))))))(else (let ((e-0 (- arg-1 1))) (let ((e-19 (car arg-3))) (let ((e-20 (cdr arg-3))) (let ((e-23 (car arg-4))) (let ((e-24 (cdr arg-4))) (cons (string-append e-23 e-20) (UnitaryLinear-addSymbol e-0 0 (cons e-19 e-20) e-24))))))))))))
(define UnitaryLinear-addSymbolCNOT (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) '() (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 0) (cond ((equal? e-3 0) (cond ((equal? arg-2 0) (if (null? arg-4) (cond ((equal? arg-3 0) (if (null? arg-4) (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))) (let ((e-12 (car arg-4))) (let ((e-13 (cdr arg-4))) (cons (string-append e-12 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) arg-2 1 e-13))))))(else (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))))) (let ((e-16 (car arg-4))) (let ((e-17 (cdr arg-4))) (cons (string-append e-16 "- \x2022; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 arg-3 e-17))))))(else (cond ((equal? arg-3 0) (if (null? arg-4) (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))) (let ((e-12 (car arg-4))) (let ((e-13 (cdr arg-4))) (cons (string-append e-12 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) arg-2 1 e-13))))))(else (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))))))))(else (let ((e-5 (- e-3 1))) (cond ((equal? arg-2 0) (let ((e-20 (car arg-4))) (let ((e-21 (cdr arg-4))) (cons (string-append e-20 "- \x2022; -") (UnitaryLinear-addSymbolCNOT (cons 0 e-5) 1 arg-3 e-21))))) (else (let ((e-24 (car arg-4))) (let ((e-25 (cdr arg-4))) (cons (string-append e-24 "--|--") (UnitaryLinear-addSymbolCNOT (cons 0 e-5) 1 0 e-25))))))))))(else (let ((e-4 (- e-2 1))) (cond ((equal? e-3 0) (cond ((equal? arg-3 0) (let ((e-29 (car arg-4))) (let ((e-30 (cdr arg-4))) (cons (string-append e-29 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons e-4 0) arg-2 1 e-30))))) (else (let ((e-33 (car arg-4))) (let ((e-34 (cdr arg-4))) (cons (string-append e-33 "--|--") (UnitaryLinear-addSymbolCNOT (cons e-4 0) 0 1 e-34)))))))(else (let ((e-26 (- e-3 1))) (let ((e-37 (car arg-4))) (let ((e-38 (cdr arg-4))) (cons (string-append e-37 "-----") (UnitaryLinear-addSymbolCNOT (cons e-4 e-26) 0 0 e-38)))))))))))))))
(define UnitaryLinear-drawWirePhase (lambda (arg-0) (cond ((equal? arg-0 0) "")(else (let ((e-0 (- arg-0 1))) (string-append "-" (UnitaryLinear-drawWirePhase e-0)))))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45TypesC-45String-length (lambda (arg-0) (PreludeC-45Types-prim__integerToNat (string-length arg-0))))
(define UnitaryLinear-newWireQVect (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons "" (UnitaryLinear-newWireQVect e-0)))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (<= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (>= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-u--showPrec_Show_Double (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Double (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Double (vector 0 ) arg-0)))
(define UnitaryLinear-printPhase (lambda (arg-0 arg-1 arg-2) (let ((sc0 (let ((sc1 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- 3.141592653589793 arg-1)))) (cond ((equal? sc1 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ 3.141592653589793 arg-1))) (else 0))))) (cond ((equal? sc0 1) arg-2) (else (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 2.0) arg-1)))) (cond ((equal? sc2 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 2.0) arg-1))) (else 0))))) (cond ((equal? sc1 1) (string-append arg-2 "/2")) (else (let ((sc2 (let ((sc3 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 3.0) arg-1)))) (cond ((equal? sc3 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 3.0) arg-1))) (else 0))))) (cond ((equal? sc2 1) (string-append arg-2 "/3")) (else (let ((sc3 (let ((sc4 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 4.0) arg-1)))) (cond ((equal? sc4 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 4.0) arg-1))) (else 0))))) (cond ((equal? sc3 1) (string-append arg-2 "/4")) (else (let ((sc4 (let ((sc5 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 6.0) arg-1)))) (cond ((equal? sc5 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 6.0) arg-1))) (else 0))))) (cond ((equal? sc4 1) (string-append arg-2 "/6")) (else (let ((sc5 (let ((sc6 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 8.0) arg-1)))) (cond ((equal? sc6 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 8.0) arg-1))) (else 0))))) (cond ((equal? sc5 1) (string-append arg-2 "/8")) (else (let ((sc6 (let ((sc7 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (- 3.141592653589793) arg-1)))) (cond ((equal? sc7 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (- 3.141592653589793) arg-1))) (else 0))))) (cond ((equal? sc6 1) (string-append "-" arg-2)) (else (let ((sc7 (let ((sc8 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 2.0) arg-1)))) (cond ((equal? sc8 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 2.0) arg-1))) (else 0))))) (cond ((equal? sc7 1) (string-append "-" (string-append arg-2 "/2"))) (else (let ((sc8 (let ((sc9 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 3.0) arg-1)))) (cond ((equal? sc9 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 3.0) arg-1))) (else 0))))) (cond ((equal? sc8 1) (string-append "-" (string-append arg-2 "/3"))) (else (let ((sc9 (let ((sc10 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 4.0) arg-1)))) (cond ((equal? sc10 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 4.0) arg-1))) (else 0))))) (cond ((equal? sc9 1) (string-append "-" (string-append arg-2 "/4"))) (else (let ((sc10 (let ((sc11 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 6.0) arg-1)))) (cond ((equal? sc11 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 6.0) arg-1))) (else 0))))) (cond ((equal? sc10 1) (string-append "-" (string-append arg-2 "/6"))) (else (let ((sc11 (let ((sc12 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 8.0) arg-1)))) (cond ((equal? sc12 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 8.0) arg-1))) (else 0))))) (cond ((equal? sc11 1) (string-append "-" (string-append arg-2 "/8"))) (else (PreludeC-45Show-u--show_Show_Double arg-0)))))))))))))))))))))))))))))))))))))))
(define UnitaryLinear-drawGate (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (UnitaryLinear-newWireQVect arg-0)) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-4 (vector-ref arg-1 3))) (UnitaryLinear-addSymbol e-2 0 (cons "- H -" "-----") (UnitaryLinear-drawGate arg-0 e-4))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-9 (vector-ref arg-1 4))) (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ 3.141592653589793 4.0) 0.001) e-6))) (cond ((equal? sc2 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ 3.141592653589793 4.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc1 1) (UnitaryLinear-addSymbol e-7 0 (cons "- T -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc2 (let ((sc3 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ (- 3.141592653589793) 4.0) 0.001) e-6))) (cond ((equal? sc3 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ (- 3.141592653589793) 4.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc2 1) (UnitaryLinear-addSymbol e-7 0 (cons "- T+ -" "------") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc3 (let ((sc4 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ 3.141592653589793 2.0) 0.001) e-6))) (cond ((equal? sc4 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ 3.141592653589793 2.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc3 1) (UnitaryLinear-addSymbol e-7 0 (cons "- S -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc4 (let ((sc5 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ (- 3.141592653589793) 2.0) 0.001) e-6))) (cond ((equal? sc5 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ (- 3.141592653589793) 2.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc4 1) (UnitaryLinear-addSymbol e-7 0 (cons "- S+ -" "------") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc5 (let ((sc6 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- 3.141592653589793 0.001) e-6))) (cond ((equal? sc6 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ 3.141592653589793 0.001) e-6)) (else 0))))) (cond ((equal? sc5 1) (UnitaryLinear-addSymbol e-7 0 (cons "- Z -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((u--s (UnitaryLinear-printPhase e-6 0.001 "\x3c0;"))) (UnitaryLinear-addSymbol e-7 0 (cons (string-append "- P(" (string-append u--s ") -")) (UnitaryLinear-drawWirePhase (+ (PreludeC-45TypesC-45String-length u--s) 7))) (UnitaryLinear-drawGate arg-0 e-9)))))))))))))))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-16 (vector-ref arg-1 6))) (UnitaryLinear-addSymbolCNOT (cons e-11 e-12) 0 0 (UnitaryLinear-drawGate arg-0 e-16)))))))))
(define UnitaryLinear-drawVect (lambda (arg-1) (if (null? arg-1) "" (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (string-append e-3 (string-append "\xa;" (UnitaryLinear-drawVect e-4))))))))
(define UnitaryLinear-draw (lambda (arg-0 arg-1) (let ((u--vs1 (UnitaryLinear-drawGate arg-0 arg-1))) (let ((u--s (UnitaryLinear-drawVect u--vs1))) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append u--s "\xa;") eta-0))))))
(define UnitaryLinear-unitarytoQiskit (lambda (arg-1) (case (vector-ref arg-1 0) ((0) "") ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-4 (vector-ref arg-1 3))) (string-append (UnitaryLinear-unitarytoQiskit e-4) (string-append "qc.h(qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-2) "])\xa;qc.barrier(qr)\xa;")))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-9 (vector-ref arg-1 4))) (string-append (UnitaryLinear-unitarytoQiskit e-9) (string-append "qc.p(" (string-append (UnitaryLinear-printPhase e-6 0.001 "np.pi") (string-append ", qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-7) "])\xa;qc.barrier(qr)\xa;"))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-16 (vector-ref arg-1 6))) (string-append (UnitaryLinear-unitarytoQiskit e-16) (string-append "qc.cx(qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-11) (string-append "], qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-12) "])\xa;qc.barrier(qr)\xa;"))))))))))))
(define UnitaryLinear-toQiskit (lambda (arg-0 arg-1) (let ((u--s (UnitaryLinear-unitarytoQiskit arg-1))) (string-append "import numpy as np\xa;" (string-append "from qiskit import QuantumCircuit\xa;" (string-append "from qiskit import QuantumRegister\xa;" (string-append "qr = QuantumRegister(" (string-append (PreludeC-45Show-u--show_Show_Nat arg-0) (string-append ")\xa;" (string-append "qc = QuantumCircuit(qr)\xa;\xa;" (string-append u--s "\xa;print(qc)")))))))))))
(define SystemC-45FileC-45Support-ok (lambda (arg-3 arg-4) (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) (vector 1 arg-4)))))))
(define SystemC-45FileC-45Error-returnError (lambda (arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Error-prim__fileErrno eta-0))))) (lambda (u--err) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (vector 0 (cond ((equal? u--err 0) (vector 1 )) ((equal? u--err 1) (vector 2 )) ((equal? u--err 2) (vector 3 )) ((equal? u--err 3) (vector 4 )) ((equal? u--err 4) (vector 5 ))(else (vector 0 (bs- u--err 5 63)))))))))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define SystemC-45FileC-45ReadWrite-fPutStr (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__writeLine arg-2 arg-3 eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--res (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 (vector 0 )))))))))))
(define SystemC-45FileC-45Handle-closeFile (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__close arg-2 eta-0))))))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) 1) (else arg-1))))
(define PreludeC-45Types-elemBy (lambda (arg-2 arg-3 arg-4 ext-0) (let ((e-6 (vector-ref arg-2 5))) (((((e-6 'erased) 'erased) (cons (lambda (arg-8474) (lambda (arg-8477) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool arg-8474 arg-8477))) 0)) (arg-3 arg-4)) ext-0))))
(define PreludeC-45Types-elem (lambda (arg-2 arg-3 ext-1 ext-0) (PreludeC-45Types-elemBy arg-2 (lambda (eta-0) (lambda (eta-1) (let ((e-1 (car arg-3))) ((e-1 eta-0) eta-1)))) ext-1 ext-0)))
(define SystemC-45Info-os (blodwen-os))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45Info-isWindows (PreludeC-45Types-elem csegen-56 (cons (lambda (arg-676) (lambda (arg-679) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-676 arg-679))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-686 arg-689)))) SystemC-45Info-os (cons "windows" (cons "mingw32" (cons "cygwin32" '())))))
(define SystemC-45FileC-45Mode-modeStr (lambda (arg-0) (cond ((equal? arg-0 0) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb") (else "r")))) ((equal? arg-0 1) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb") (else "w")))) ((equal? arg-0 2) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab") (else "a")))) ((equal? arg-0 3) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb+") (else "r+")))) ((equal? arg-0 4) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb+") (else "w+")))) (else (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab+") (else "a+")))))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45FileC-45Handle-openFile (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__open arg-2 (SystemC-45FileC-45Mode-modeStr arg-3) eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr u--res) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 u--res))))))))))
(define SystemC-45FileC-45Handle-withFile (lambda (arg-3 arg-4 arg-5 arg-6 arg-7) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FileC-45Handle-openFile arg-3 arg-4 arg-5)) (lambda (_-0) (case (vector-ref _-0 0) ((1) (let ((e-6 (vector-ref _-0 1))) (let ((e-8 (car arg-3))) (let ((e-10 (vector-ref e-8 1))) ((((e-10 'erased) 'erased) (arg-7 e-6)) (lambda (u--res) (let ((e-13 (car arg-3))) (let ((e-15 (vector-ref e-13 1))) ((((e-15 'erased) 'erased) (SystemC-45FileC-45Handle-closeFile arg-3 e-6)) (lambda (_-10649) (let ((e-18 (car arg-3))) (let ((e-21 (vector-ref e-18 0))) (let ((e-23 (vector-ref e-21 1))) ((e-23 'erased) u--res)))))))))))))) (else (let ((e-6 (vector-ref _-0 1))) (let ((e-8 (car arg-3))) (let ((e-11 (vector-ref e-8 0))) (let ((e-14 (vector-ref e-11 0))) ((((e-14 'erased) 'erased) (lambda (eta-0) (vector 0 eta-0))) (arg-6 e-6))))))))))))))
(define SystemC-45FileC-45ReadWrite-writeFile (lambda (arg-1 arg-2 arg-3) (SystemC-45FileC-45Handle-withFile arg-1 arg-2 1 (lambda (eta-0) (let ((e-1 (car arg-1))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) eta-0))))) (lambda (eta-0) (PreludeC-45Basics-flip (lambda (eta-1) (lambda (eta-2) (SystemC-45FileC-45ReadWrite-fPutStr arg-1 eta-1 eta-2))) arg-3 eta-0)))))
(define UnitaryLinear-exportToQiskit (lambda (arg-0 arg-1 arg-2) (let ((u--s (UnitaryLinear-toQiskit arg-0 arg-2))) (lambda (world-0) (let ((act-1 ((SystemC-45FileC-45ReadWrite-writeFile csegen-115 arg-1 u--s) world-0))) (case (vector-ref act-1 0) ((0) (PreludeC-45IO-prim__putStr "Error when writing file\xa;" world-0)) (else (vector 0 ))))))))
(define QuantumOp-applyUSTRC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (let ((sc0 (arg-2 (vector 0 )))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((u--unew (UnitaryLinear-compose e-2 arg-3))) (cons u--unew e-3)))))))
(define QuantumOp-applyUSTSimulatedR (lambda (arg-0 arg-1 arg-2 ext-0) (QuantumOp-applyUSTRC-39 arg-0 arg-1 arg-2 ext-0)))
(define QuantumOp-idUp (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-2 0) arg-1)(else (let ((e-0 (- arg-2 1))) (UnitaryLinear-tensor arg-0 (+ e-0 1) arg-1 (vector 0 )))))))
(define QuantumOp-mkQubitV (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) '())(else (let ((e-1 (- arg-1 1))) (cons 0 (QuantumOp-mkQubitV 1 e-1))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) '())(else (let ((e-2 (- arg-1 1))) (cons (+ e-0 1) (QuantumOp-mkQubitV (+ (+ e-0 1) 1) e-2))))))))))
(define QuantumOp-newQubitsPointersNoCount (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) (cons '() '()))(else (let ((e-0 (- arg-1 1))) (let ((u--newcounter (QuantumOp-reCalculateCounter arg-0 arg-2))) (let ((sc0 (QuantumOp-newQubitsPointersNoCount (+ arg-0 1) e-0 (cons u--newcounter arg-2)))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (cons (cons u--newcounter e-2) (cons u--newcounter e-3)))))))))))
(define QuantumOp-n--13626-17360-u--newQubitsC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((sc0 (QuantumOp-newQubitsPointersNoCount arg-2 arg-3 (QuantumOp-mkQubitV 0 arg-2)))) (let ((e-2 (car sc0))) (cons (QuantumOp-idUp arg-2 arg-4 arg-3) e-2)))))
(define QuantumOp-newQubitsUST (lambda (arg-0 arg-1 ext-0) (QuantumOp-n--13626-17360-u--newQubitsC-39 arg-0 arg-1 arg-0 arg-1 ext-0)))
(define QFT-RmOwn (lambda (arg-1 arg-2 arg-3 arg-4 ext-0) (UStateT-C-62C-62C-61 (let ((e-4 (vector-ref arg-1 3))) (((e-4 arg-2) (/ (* 2.0 3.141592653589793) (flexpt 2.0 (exact->inexact arg-3)))) arg-4)) (lambda (u--q) (lambda (eta-0) (cons eta-0 u--q))) ext-0)))
(define QFT-cRmAbs (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-2 0) (lambda (eta-0) (cons eta-0 (cons arg-4 (cons arg-5 '())))))(else (let ((e-0 (- arg-2 1))) (lambda (eta-0) (UStateT-C-62C-62C-61 (let ((e-6 (vector-ref arg-1 5))) ((((e-6 e-0) 1) arg-4) (lambda (eta-1) (QFT-RmOwn arg-1 e-0 arg-3 arg-5 eta-1)))) (lambda (u--cu) (lambda (eta-1) (cons eta-1 u--cu))) eta-0)))))))
(define QFT-rotateAbs (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6) (cond ((equal? arg-3 0) (lambda (clam-0) (cons clam-0 (cons arg-5 '()))))(else (let ((e-0 (- arg-3 1))) (lambda (clam-1) (let ((e-4 (car arg-6))) (let ((e-5 (cdr arg-6))) (UStateT-C-62C-62C-61 (QFT-cRmAbs arg-1 arg-2 arg-4 e-4 arg-5) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-0) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (UStateT-C-62C-62C-61 (QFT-rotateAbs arg-1 arg-2 e-0 (+ arg-4 1) e-6 e-5) (lambda (_-1) (lambda (clam-3) (let ((e-9 (car _-1))) (let ((e-8 (cdr _-1))) (cons clam-3 (cons e-9 (cons e-2 e-8))))))) clam-0))))))) clam-1)))))))))
(define QFT-qftUAbs (lambda (arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-3 0) (if (null? arg-4) (lambda (eta-0) (cons eta-0 '())) (cond ((equal? arg-2 0) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (lambda (clam-0) (let ((e-4 (car arg-4))) (let ((e-5 (cdr arg-4))) (cons clam-0 (cons e-4 e-5))))))))(else (let ((e-0 (- arg-2 1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-6 (- arg-3 1))) (lambda (clam-1) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (UStateT-C-62C-62C-61 (let ((e-3 (vector-ref arg-1 2))) ((e-3 (+ e-0 1)) e-9)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (UStateT-C-62C-62C-61 (QFT-rotateAbs arg-1 (+ e-0 1) e-6 2 e-2 e-10) (lambda (_-1) (lambda (clam-3) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (QFT-qftUAbs arg-1 (+ e-0 1) e-6 e-4) (lambda (u--qsC-39C-39) (lambda (eta-0) (cons eta-0 (cons e-5 u--qsC-39C-39)))) clam-3))))) clam-0))))) clam-1))))))))))))(else (cond ((equal? arg-2 0) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (lambda (clam-4) (let ((e-4 (car arg-4))) (let ((e-5 (cdr arg-4))) (cons clam-4 (cons e-4 e-5))))))))(else (let ((e-0 (- arg-2 1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-6 (- arg-3 1))) (lambda (clam-5) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (UStateT-C-62C-62C-61 (let ((e-3 (vector-ref arg-1 2))) ((e-3 (+ e-0 1)) e-9)) (lambda (_-0) (lambda (clam-1) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (UStateT-C-62C-62C-61 (QFT-rotateAbs arg-1 (+ e-0 1) e-6 2 e-2 e-10) (lambda (_-1) (lambda (clam-7) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (QFT-qftUAbs arg-1 (+ e-0 1) e-6 e-4) (lambda (u--qsC-39C-39) (lambda (eta-0) (cons eta-0 (cons e-5 u--qsC-39C-39)))) clam-7))))) clam-1))))) clam-5))))))))))))))
(define QuantumOp-case--runUnitaryOpC-39-18482 (lambda (arg-0 arg-1 arg-2) (let ((e-2 (car arg-2))) e-2)))
(define QuantumOp-runUnitaryOpC-39 (lambda (arg-0 arg-1) (QuantumOp-case--runUnitaryOpC-39-18482 arg-0 arg-1 (arg-1 (vector 0 )))))
(define UnitarySimulated-duplicateLinU (lambda (arg-1) (case (vector-ref arg-1 0) ((0) (cons (vector 0 ) (vector 0 ))) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((sc1 (UnitarySimulated-duplicateLinU e-4))) (let ((e-6 (car sc1))) (let ((e-5 (cdr sc1))) (cons (vector 1 e-2 e-3 e-6) (vector 1 e-2 e-3 e-5))))))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((sc1 (UnitarySimulated-duplicateLinU e-9))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons (vector 2 e-6 e-7 e-8 e-2) (vector 2 e-6 e-7 e-8 e-3)))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (let ((sc1 (UnitarySimulated-duplicateLinU e-16))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons (vector 3 e-11 e-12 e-13 e-14 e-15 e-2) (vector 3 e-11 e-12 e-13 e-14 e-15 e-3)))))))))))))))
(define UnitarySimulated-case--caseC-32blockC-32inC-32invert-20819 (lambda (arg-2 arg-5 arg-6) (let ((e-2 (car arg-6))) (let ((u--invu (UnitaryLinear-adjoint e-2))) (let ((sc1 (UnitarySimulated-duplicateLinU arg-2))) (let ((e-5 (car sc1))) (let ((u--unew (UnitaryLinear-compose u--invu e-5))) (cons u--unew arg-5))))))))
(define UnitarySimulated-invert (lambda (arg-2 arg-3) (let ((sc0 (arg-2 (vector 0 )))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (UnitarySimulated-case--caseC-32blockC-32inC-32invert-20819 arg-3 e-3 (UnitarySimulated-duplicateLinU e-2)))))))
(define UnitarySimulated-adjointUSTC-39 (lambda (arg-2 ext-0) (UnitarySimulated-invert arg-2 ext-0)))
(define UnitarySimulated-u--adjointUST_UnitaryOp_Unitary (lambda (ext-1 ext-0) (UnitarySimulated-adjointUSTC-39 ext-1 ext-0)))
(define QuantumOp-makeNeutralVectC-39 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons e-0 (QuantumOp-makeNeutralVectC-39 e-0)))))))
(define DataC-45Vect-reverseOnto (lambda (arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (DataC-45Vect-reverseOnto (cons e-3 arg-3) e-4))))))
(define DataC-45Vect-reverse (lambda (ext-0) (DataC-45Vect-reverseOnto '() ext-0)))
(define QuantumOp-makeNeutralVect (lambda (arg-0) (DataC-45Vect-reverse (QuantumOp-makeNeutralVectC-39 arg-0))))
(define UnitarySimulated-case--applyUnitaryC-39-20272 (lambda (arg-0 arg-1 arg-2 arg-3 arg-5) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((sc1 (Injection-decInj arg-0 e-3))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (let ((u--unew (UnitaryLinear-apply arg-2 arg-0 arg-3 arg-1 e-3 e-1))) (cons u--unew e-2)))) (else (let ((u--applicable (QuantumOp-makeNeutralVect arg-2))) (let ((sc2 (UnitaryLinear-applyOrErrorIO arg-2 arg-0 arg-3 arg-1 u--applicable))) (let ((e-6 (car sc2))) (cons e-6 e-2)))))))))))
(define UnitarySimulated-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (UnitarySimulated-case--applyUnitaryC-39-20272 arg-0 arg-4 arg-1 arg-3 (QuantumOp-distributeDupedLVectVect arg-2))))
(define UnitarySimulated-applyInternal (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-applyCNOTSim (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 2 (cons arg-1 (cons arg-2 '())) UnitaryLinear-CNOTGate eta-0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-0) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons clam-0 (cons e-2 (cons e-6 '()))))))))) ext-0)))
(define UnitarySimulated-u--applyCNOT_UnitaryOp_Unitary (lambda (arg-0 ext-2 ext-1 ext-0) (UnitarySimulated-applyCNOTSim arg-0 ext-2 ext-1 ext-0)))
(define UnitarySimulated-findInLin (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (if (null? arg-2) (let ((e-3 (cdr arg-2))) e-3) '()))(else (let ((e-4 (- arg-0 1))) (if (null? arg-2) (let ((e-3 (cdr arg-2))) e-3) (let ((e-11 (car arg-2))) (let ((e-12 (cdr arg-2))) (let ((sc1 (DecidableC-45Equality-u--decEq_DecEq_Nat arg-1 e-11))) (case (vector-ref sc1 0) ((0) e-12) (else (cons e-11 (UnitarySimulated-findInLin e-4 arg-1 e-12)))))))))))))
(define UnitarySimulated-reCalculateNew (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) 0)(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (QuantumOp-smallestMissing (DataC-45VectC-45Sort-sort csegen-106 (+ e-0 1) (cons e-4 e-5))))))))))
(define UnitarySimulated-newVectOrder (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (let ((u--newcounter (UnitarySimulated-reCalculateNew arg-0 arg-2))) (cons u--newcounter (UnitarySimulated-newVectOrder (+ arg-0 1) e-0 (cons u--newcounter arg-2)))))))))
(define UnitarySimulated-newVectOrderN (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (if (null? arg-2) (UnitarySimulated-newVectOrder 0 arg-1 '()) (let ((sc2 (DataC-45Nat-isLTE arg-0 arg-1))) (case (vector-ref sc2 0) ((0) (let ((u--vect (DataC-45Vect-C-43C-43 arg-2 (UnitarySimulated-newVectOrder arg-0 (PreludeC-45Types-prim__integerToNat (- arg-1 arg-0)) arg-2)))) u--vect)) (else (QuantumOp-makeNeutralVect arg-1))))))(else (let ((sc0 (DataC-45Nat-isLTE arg-0 arg-1))) (case (vector-ref sc0 0) ((0) (let ((u--vect (DataC-45Vect-C-43C-43 arg-2 (UnitarySimulated-newVectOrder arg-0 (PreludeC-45Types-prim__integerToNat (- arg-1 arg-0)) arg-2)))) u--vect)) (else (QuantumOp-makeNeutralVect arg-1))))))))
(define QuantumOp-splitLVinto (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (if (null? arg-2) (cons '() '()) (cons '() arg-2)))(else (cons '() arg-2))))(else (cond ((equal? arg-1 0) (cons arg-2 '()))(else (cond ((equal? arg-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (- arg-1 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc1 (QuantumOp-splitLVinto e-0 (+ e-1 1) e-5))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons (cons e-4 e-2) e-3))))))))))))))))))
(define UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlledUSplitSimC-39-19737 (lambda (arg-0 arg-1 arg-2 arg-3 arg-6 arg-7 arg-8 arg-11 arg-12 arg-13 arg-14 arg-15) (case (vector-ref arg-15 0) ((0) (let ((e-1 (vector-ref arg-15 1))) (let ((u--unew (UnitaryLinear-apply (+ arg-2 1) (+ arg-2 1) (UnitaryLinear-controlled arg-2 arg-8) arg-3 (cons arg-7 arg-14) e-1))) (let ((sc1 (QuantumOp-splitLVinto arg-0 arg-1 arg-11))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons u--unew (cons (cons arg-6 e-2) e-3)))))))) (else (let ((u--applicableSn (QuantumOp-makeNeutralVect (+ arg-2 1)))) (let ((sc1 (UnitaryLinear-applyOrErrorIO (+ arg-2 1) (+ arg-2 1) (UnitaryLinear-controlled arg-2 arg-8) arg-3 u--applicableSn))) (let ((e-2 (car sc1))) (let ((sc2 (QuantumOp-splitLVinto arg-0 arg-1 arg-11))) (let ((e-6 (car sc2))) (let ((e-5 (cdr sc2))) (cons e-2 (cons (cons arg-6 e-6) e-5))))))))))))
(define UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlledUSplitSimC-39-19691 (lambda (arg-0 arg-1 arg-2 arg-3 arg-6 arg-7 arg-8 arg-11) (let ((e-2 (car arg-11))) (let ((e-3 (cdr arg-11))) (let ((u--v (UnitarySimulated-newVectOrderN (+ arg-0 arg-1) (+ arg-2 1) e-3))) (let ((u--vn (UnitarySimulated-findInLin arg-2 arg-7 u--v))) (UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlledUSplitSimC-39-19737 arg-0 arg-1 arg-2 arg-3 arg-6 arg-7 arg-8 e-2 e-3 u--v u--vn (Injection-decInj (+ arg-2 1) (cons arg-7 u--vn)))))))))
(define UnitarySimulated-applyControlledUSplitSimC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (let ((sc0 (QuantumOp-qubitToNatPair arg-3))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((sc1 (arg-4 (vector 0 )))) (let ((e-5 (car sc1))) (let ((e-4 (cdr sc1))) (let ((e-6 (car e-4))) (let ((e-7 (cdr e-4))) (UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlledUSplitSimC-39-19691 arg-0 arg-1 arg-2 arg-5 e-2 e-3 e-5 (QuantumOp-distributeDupedLVectVect (LinearTypes-C-43C-43 e-6 e-7)))))))))))))
(define UnitarySimulated-applyControlledSimulatedSplit (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (UnitarySimulated-applyControlledUSplitSimC-39 arg-0 arg-1 arg-2 arg-3 arg-4 ext-0)))
(define UnitarySimulated-u--applyControlWithSplitLVects_UnitaryOp_Unitary (lambda (arg-0 arg-1 arg-2 ext-2 ext-1 ext-0) (UnitarySimulated-applyControlledSimulatedSplit arg-0 arg-1 arg-2 ext-2 ext-1 ext-0)))
(define UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlSimulatedC-39-19120 (lambda (arg-0 arg-1 arg-2 arg-5 arg-6 arg-7 arg-9) (let ((e-2 (car arg-9))) (let ((e-3 (cdr arg-9))) (let ((u--v (UnitarySimulated-newVectOrderN arg-2 (+ arg-0 1) e-3))) (let ((u--vn (UnitarySimulated-findInLin arg-0 arg-6 u--v))) (let ((sc1 (Injection-decInj (+ arg-0 1) (cons arg-6 u--vn)))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (let ((u--unew (UnitaryLinear-apply (+ arg-0 1) (+ arg-0 1) (UnitaryLinear-controlled arg-0 arg-7) arg-1 (cons arg-6 u--vn) e-1))) (cons u--unew (cons arg-5 e-2))))) (else (let ((u--applicableSn (QuantumOp-makeNeutralVect (+ arg-0 1)))) (let ((sc2 (UnitaryLinear-applyOrErrorIO (+ arg-0 1) (+ arg-0 1) (UnitaryLinear-controlled arg-0 arg-7) arg-1 u--applicableSn))) (let ((e-6 (car sc2))) (cons e-6 (cons arg-5 e-2))))))))))))))
(define UnitarySimulated-applyControlSimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((sc0 (QuantumOp-qubitToNatPair arg-2))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((sc1 (arg-3 (vector 0 )))) (let ((e-5 (car sc1))) (let ((e-4 (cdr sc1))) (UnitarySimulated-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32applyControlSimulatedC-39-19120 arg-0 arg-4 arg-1 e-2 e-3 e-5 (QuantumOp-distributeDupedLVectVect e-4))))))))))
(define UnitarySimulated-applyControlAbsSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyControlSimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyControlledAbs_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyControlAbsSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-applyHSim (lambda (arg-0 arg-1 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 1 (cons arg-1 '()) UnitaryLinear-HGate eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitarySimulated-u--applyH_UnitaryOp_Unitary (lambda (arg-0 ext-1 ext-0) (UnitarySimulated-applyHSim arg-0 ext-1 ext-0)))
(define UnitarySimulated-applyPSim (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 1 (cons arg-2 '()) (UnitaryLinear-PGate arg-1) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitarySimulated-u--applyP_UnitaryOp_Unitary (lambda (arg-0 ext-2 ext-1 ext-0) (UnitarySimulated-applyPSim arg-0 ext-2 ext-1 ext-0)))
(define UnitarySimulated-applyParallelSimulatedC-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (let ((sc0 (arg-3 (vector 0 )))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((sc1 (arg-4 (vector 0 )))) (let ((e-5 (car sc1))) (let ((e-4 (cdr sc1))) (let ((u--unewest (UnitaryLinear-compose e-2 arg-5))) (let ((u--uOut (UnitaryLinear-compose e-5 u--unewest))) (cons u--uOut (LinearTypes-C-43C-43 e-3 e-4))))))))))))
(define UnitarySimulated-applyParallelSimulated (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (UnitarySimulated-applyParallelSimulatedC-39 arg-0 arg-1 arg-3 arg-4 ext-0)))
(define UnitarySimulated-u--applyParallel_UnitaryOp_Unitary (lambda (arg-0 arg-1 arg-2 ext-2 ext-1 ext-0) (UnitarySimulated-applyParallelSimulated arg-0 arg-1 arg-2 ext-2 ext-1 ext-0)))
(define UnitarySimulated-case--applyUnitaryOwnC-39-20433 (lambda (arg-0 arg-1 arg-2 arg-3 arg-5) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((sc1 (Injection-decInj arg-0 e-3))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (let ((u--unew (UnitaryLinear-apply arg-1 arg-0 arg-3 arg-2 e-3 e-1))) (cons u--unew e-2)))) (else (let ((u--applicable (QuantumOp-makeNeutralVect arg-1))) (let ((sc2 (UnitaryLinear-applyOrErrorIO arg-1 arg-0 arg-3 arg-2 u--applicable))) (let ((e-6 (car sc2))) (cons e-6 e-2)))))))))))
(define UnitarySimulated-applyUnitaryOwnC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (UnitarySimulated-case--applyUnitaryOwnC-39-20433 arg-0 arg-1 arg-4 arg-3 (QuantumOp-distributeDupedLVectVect arg-2))))
(define UnitarySimulated-applyUnitaryOwnSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryOwnC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyUnitaryOwn_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyUnitaryOwnSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyUnitary_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyUnitarySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-exportUnitarySelf (lambda (arg-1 arg-2 arg-3) (let ((sc0 (arg-3 arg-2))) (let ((e-2 (car sc0))) e-2))))
(define UnitarySimulated-u--exportSelf_UnitaryOp_Unitary (lambda (arg-1 ext-0 ext-1) (UnitarySimulated-exportUnitarySelf arg-1 ext-0 ext-1)))
(define UnitarySimulated-reCombineAbsC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((sc0 (arg-3 arg-4))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons e-2 (LinearTypes-C-43C-43 e-6 e-7)))))))))
(define UnitarySimulated-reCombineAbsUnitarySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-reCombineAbsC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--reCombineAbs_UnitaryOp_Unitary (lambda (arg-0 arg-1 arg-2 ext-1 ext-0) (UnitarySimulated-reCombineAbsUnitarySimulated arg-2 arg-0 arg-1 ext-1 ext-0)))
(define UnitarySimulated-u--reCombine_UnitaryOp_Unitary (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 ext-0) (cons ext-0 (LinearTypes-C-43C-43 arg-3 arg-4))))
(define UnitarySimulated-u--run_UnitaryOp_Unitary (lambda (arg-1 ext-0 ext-1) (ext-1 ext-0)))
(define Main-qftControlTest (lambda () (QuantumOp-runUnitaryOpC-39 4 (lambda (eta-0) (UStateT-C-62C-62C-61 (lambda (eta-1) (QuantumOp-newQubitsUST 0 1 eta-1)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (UStateT-C-62C-62C-61 (lambda (eta-1) (QuantumOp-newQubitsUST 1 3 eta-1)) (lambda (_-1) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (let ((e-6 (car e-4))) (let ((e-7 (cdr e-4))) (lambda (clam-1) (let ((e-10 (car e-7))) (let ((e-11 (cdr e-7))) (UStateT-C-62C-62C-61 (lambda (eta-1) (QuantumOp-applyUSTSimulatedR 4 4 (lambda (eta-2) (UnitarySimulated-u--applyControlledAbs_UnitaryOp_Unitary 3 3 e-5 (QFT-qftUAbs (vector (lambda (u--n) (lambda (u--i) (lambda (arg-9803) (lambda (arg-9806) (lambda (eta-3) (UnitarySimulated-u--applyUnitary_UnitaryOp_Unitary u--n u--i arg-9803 arg-9806 eta-3)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9819) (lambda (u--ownUnitary) (lambda (eta-3) (UnitarySimulated-u--applyUnitaryOwn_UnitaryOp_Unitary u--n u--i arg-9819 u--ownUnitary eta-3)))))) (lambda (u--n) (lambda (arg-9832) (lambda (eta-3) (UnitarySimulated-u--applyH_UnitaryOp_Unitary u--n arg-9832 eta-3)))) (lambda (u--n) (lambda (arg-9844) (lambda (arg-9847) (lambda (eta-3) (UnitarySimulated-u--applyP_UnitaryOp_Unitary u--n arg-9844 arg-9847 eta-3))))) (lambda (u--n) (lambda (arg-9860) (lambda (arg-9863) (lambda (eta-3) (UnitarySimulated-u--applyCNOT_UnitaryOp_Unitary u--n arg-9860 arg-9863 eta-3))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9878) (lambda (arg-9881) (lambda (eta-3) (UnitarySimulated-u--applyControlledAbs_UnitaryOp_Unitary u--n u--i arg-9878 arg-9881 eta-3)))))) (lambda (u--n) (lambda (u--i) (lambda (u--j) (lambda (arg-9899) (lambda (arg-9902) (lambda (eta-3) (UnitarySimulated-u--applyParallel_UnitaryOp_Unitary u--n u--i u--j arg-9899 arg-9902 eta-3))))))) (lambda (u--i) (lambda (u--n) (lambda (arg-9914) (lambda (eta-3) (UnitarySimulated-u--adjointUST_UnitaryOp_Unitary arg-9914 eta-3))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9922) (lambda (arg-9925) (UnitarySimulated-u--run_UnitaryOp_Unitary u--i arg-9922 arg-9925))))) (lambda (u--n) (lambda (u--i) (lambda (arg-9935) (lambda (arg-9938) (UnitarySimulated-u--exportSelf_UnitaryOp_Unitary u--i arg-9935 arg-9938))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9952) (lambda (arg-9955) (lambda (eta-3) (UnitarySimulated-u--reCombine_UnitaryOp_Unitary u--i u--j u--n arg-9952 arg-9955 eta-3))))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9973) (lambda (eta-3) (UnitarySimulated-u--reCombineAbs_UnitaryOp_Unitary u--i u--j u--n arg-9973 eta-3)))))) (lambda (u--i) (lambda (u--j) (lambda (u--n) (lambda (arg-9990) (lambda (arg-9993) (lambda (eta-3) (UnitarySimulated-u--applyControlWithSplitLVects_UnitaryOp_Unitary u--i u--j u--n arg-9990 arg-9993 eta-3)))))))) 3 3 (cons e-2 (cons e-6 (cons e-10 '())))) eta-2)) eta-1)) (lambda (u--out) (lambda (eta-1) (cons eta-1 u--out))) clam-1))))))))) clam-0))))) eta-0)))))
(define Main-qftControlTestIo (lambda () (let ((u--un (Main-qftControlTest))) (lambda (world-0) (let ((act-1 ((UnitaryLinear-draw 4 u--un) world-0))) (let ((act-2 ((UnitaryLinear-exportToQiskit 4 "qftControlTest.py" u--un) world-0))) (vector 0 )))))))
(define Examples-toBellBasis (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) csegen-186))
(define Examples-adjoint_example1 (UnitaryLinear-adjoint Examples-toBellBasis))
(define Examples-adjoint_example2 (UnitaryLinear-adjoint UnitaryLinear-toffoli))
(define Examples-drawAdjointExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using adjoint\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : adjoint toBellBasis\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 2 Examples-adjoint_example1) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : adjoint toffoli\xa;" ext-0))) ((UnitaryLinear-draw 3 Examples-adjoint_example2) ext-0)))))))
(define Examples-compose_example1 (UnitaryLinear-compose UnitaryLinear-TGate UnitaryLinear-HGate))
(define Examples-compose_example2 (UnitaryLinear-compose (vector 1 1 2 (vector 0 )) (UnitaryLinear-compose (vector 2 3.141592653589793 0 (Lemmas-lemma1LTESucc 1) (vector 0 )) Examples-toBellBasis)))
(define Examples-drawComposeExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using composition\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : TGate . HGate\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 1 Examples-compose_example1) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : (H 1 IdGate) . (P pi 0 IdGate) . toBellBasis\xa;" ext-0))) ((UnitaryLinear-draw 2 Examples-compose_example2) ext-0)))))))
(define UnitaryLinear-addDepth (lambda (arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-2 0) (let ((e-4 (cdr arg-3))) (cons arg-1 e-4)))(else (let ((e-0 (- arg-2 1))) (let ((e-7 (car arg-3))) (let ((e-8 (cdr arg-3))) (cons e-7 (UnitaryLinear-addDepth arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4))))))))))
(define UnitaryLinear-findValue (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (let ((e-3 (car arg-2))) e-3))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-2))) (UnitaryLinear-findValue e-0 e-8 (DataC-45Nat-fromLteSucc arg-3))))))))
(define UnitaryLinear-depthC-39 (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (DataC-45Vect-replicate arg-0 0)) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-4))) (let ((u--k (UnitaryLinear-findValue e-2 u--v e-3))) (UnitaryLinear-addDepth (+ u--k 1) e-2 u--v e-3))))))) ((2) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-9))) (let ((u--k (UnitaryLinear-findValue e-7 u--v e-8))) (UnitaryLinear-addDepth (+ u--k 1) e-7 u--v e-8))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-16 (vector-ref arg-1 6))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-16))) (let ((u--k (UnitaryLinear-findValue e-11 u--v e-13))) (let ((u--m (UnitaryLinear-findValue e-12 u--v e-14))) (let ((sc1 (PreludeC-45Types-u--C-60_Ord_Nat u--k u--m))) (cond ((equal? sc1 1) (let ((u--w (UnitaryLinear-addDepth (+ u--m 1) e-11 u--v e-13))) (UnitaryLinear-addDepth (+ u--m 1) e-12 u--w e-14))) (else (let ((u--w (UnitaryLinear-addDepth (+ u--k 1) e-11 u--v e-13))) (UnitaryLinear-addDepth (+ u--k 1) e-12 u--w e-14)))))))))))))))))
(define DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) arg-4 (let ((e-3 (car arg-5))) (let ((e-4 (cdr arg-5))) (DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 arg-3 ((arg-3 arg-4) e-3) e-4))))))
(define UnitaryLinear-depth (lambda (arg-0 arg-1) (let ((u--v (UnitaryLinear-depthC-39 arg-0 arg-1))) (DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 (lambda (eta-0) (lambda (eta-1) (PreludeC-45Types-u--max_Ord_Nat eta-0 eta-1))) 0 u--v))))
(define Examples-depthExample2 (vector 1 2 3 (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 1 0 (Lemmas-lemma1LTESucc 2) csegen-220))))
(define Examples-depthExample3 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (vector 3 2 0 3 (Lemmas-lemma1LTESucc 2) (vector 1 (Lemmas-lemma1LTESucc 1)) (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 2 3.141592653589793 1 (+ (Lemmas-lemma1LTESucc 1) 1) csegen-220))))))
(define Examples-drawDepthExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples of depth computation\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;\xa;The depth of the following circuit\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 3 Examples-depthExample2) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr (string-append (string-append "is " (PreludeC-45Show-u--show_Show_Nat (UnitaryLinear-depth 3 Examples-depthExample2))) "\xa;") ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;\xa;The depth of the following circuit\xa;" ext-0))) (let ((act-6 ((UnitaryLinear-draw 3 Examples-depthExample3) ext-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "is " (PreludeC-45Show-u--show_Show_Nat (UnitaryLinear-depth 3 Examples-depthExample3))) "\xa;") ext-0)))))))))
(define Examples-parametrized_example1 (lambda (arg-0) (cond ((equal? arg-0 1) UnitaryLinear-HGate) (else (UnitaryLinear-PGate 3.141592653589793)))))
(define Examples-parametrized_example2 (lambda (arg-0 arg-1 arg-2) (UnitaryLinear-compose UnitaryLinear-CNOTGate (UnitaryLinear-compose (cond ((equal? arg-0 1) csegen-186) (else (vector 0 ))) (cond ((equal? arg-1 1) (vector 0 )) (else (vector 2 arg-2 1 2 (vector 0 ))))))))
(define Examples-drawParamExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples of circuits parametrized by classical data\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : for b : bool , if b then HGate else PGate pi\xa;" ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "For b = True : \xa;" ext-0))) (let ((act-4 ((UnitaryLinear-draw 1 (Examples-parametrized_example1 1)) ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "For b = False : \xa;" ext-0))) (let ((act-6 ((UnitaryLinear-draw 1 (Examples-parametrized_example1 0)) ext-0))) (let ((act-7 (PreludeC-45IO-prim__putStr "Example 2 : for b1, b2 : Bool and p : Double , CNOTGate . (if b1 then H 0 IdGate else IdGate) . (if b2 then IdGate else P p 1 IdGate)\xa;" ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "For b1 = True, b2 = False, p = pi/2\xa;" ext-0))) ((UnitaryLinear-draw 2 (Examples-parametrized_example2 1 0 (/ 3.141592653589793 2.0))) ext-0)))))))))))
(define Examples-tensorExample1 (lambda () (UnitaryLinear-tensor 1 3 UnitaryLinear-HGate (UnitaryLinear-tensor 1 2 (UnitaryLinear-PGate 3.141592653589793) UnitaryLinear-CNOTGate))))
(define UnitaryLinear-tensorMap (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (vector 0 ))(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (UnitaryLinear-tensor arg-1 (* e-0 arg-1) e-4 (UnitaryLinear-tensorMap e-0 arg-1 e-5)))))))))
(define Examples-tensorMapExample (lambda () (UnitaryLinear-tensorMap 3 2 (cons UnitaryLinear-CNOTGate (cons Examples-toBellBasis (cons UnitaryLinear-CNOTGate '()))))))
(define UnitaryLinear-tensorMapSimple (lambda (arg-0 arg-1) (UnitaryLinear-tensorMap arg-0 1 arg-1)))
(define Examples-tensorMapSimpleExample (lambda () (UnitaryLinear-tensorMapSimple 3 (cons UnitaryLinear-HGate (cons (UnitaryLinear-PGate 3.141592653589793) (cons UnitaryLinear-HGate '()))))))
(define UnitaryLinear-tensorn (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 ))(else (let ((e-0 (- arg-0 1))) (UnitaryLinear-tensor 1 e-0 arg-1 (UnitaryLinear-tensorn e-0 arg-1)))))))
(define Examples-tensornExample (lambda () (UnitaryLinear-tensorn 3 UnitaryLinear-HGate)))
(define Examples-drawTensorExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using tensor product\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : HGate # PGate pi # CNOTGate\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 4 (Examples-tensorExample1)) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : tensorn 3 HGate\xa;" ext-0))) (let ((act-5 ((UnitaryLinear-draw 3 (Examples-tensornExample)) ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "Example 3 : tensorMapSimple [HGate, PGate pi, HGate]\xa;" ext-0))) (let ((act-7 ((UnitaryLinear-draw 3 (Examples-tensorMapSimpleExample)) ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "Example 4 : tensorMap [CNOTGate, toBellBasis, CNOTGate]\xa;" ext-0))) ((UnitaryLinear-draw 6 (Examples-tensorMapExample)) ext-0)))))))))))
(define Examples-toBellBasis2 (lambda () (UnitaryLinear-compose UnitaryLinear-CNOTGate (UnitaryLinear-tensor 1 1 UnitaryLinear-HGate (vector 0 )))))
(define Examples-drawToBellBasis2 (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "\xa;Another possibility for toBellBasis: \xa;CNOTGate . (HGate # IdGate)\xa;" ext-0))) ((UnitaryLinear-draw 2 (Examples-toBellBasis2)) ext-0))))
(define Examples-exampleComposeTensor1 (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "\xa;An example of usage of compose, tensor and adjoint: \xa;(adjoint toBellBasis # IdGate) . (TGate # toBellBasis)\xa;" ext-0))) (((let ((u--circuit (UnitaryLinear-compose (UnitaryLinear-tensor 2 1 (UnitaryLinear-adjoint Examples-toBellBasis) (vector 0 )) (UnitaryLinear-tensor 1 2 UnitaryLinear-TGate Examples-toBellBasis)))) (lambda () (UnitaryLinear-draw 3 u--circuit)))) ext-0))))
(define Examples-drawExamples (lambda (ext-0) (let ((act-1 (Examples-drawComposeExamples ext-0))) (let ((act-2 (Examples-drawTensorExamples ext-0))) (let ((act-3 (Examples-drawToBellBasis2 ext-0))) (let ((act-4 (Examples-drawAdjointExamples ext-0))) (let ((act-5 (Examples-exampleComposeTensor1 ext-0))) (let ((act-6 (Examples-drawParamExamples ext-0))) (Examples-drawDepthExamples ext-0)))))))))
(define Main-main (lambda (ext-0) (let ((act-1 (Examples-drawExamples ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;Test coin toss by performing 1000 coin tosses.\xa;" ext-0))) (let ((act-3 ((Main-testCoins) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "\xa;Test 'Repeat Until Success'. Probability to measure '1' is 2/3 for this example.\xa;" ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;Small test with VQE\xa;" ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "\xa;Small test with Encoding in VQE\xa;" ext-0))) (let ((act-7 ((Main-qftControlTestIo) ext-0))) (vector 0 ))))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (let ((eff-0 (arg-1 u--w))) eff-0)))))
(collect-request-handler (lambda () (collect) (blodwen-run-finalisers)))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))
  (collect 4)
  (blodwen-run-finalisers)
  
  )