#!/opt/homebrew/bin/chez --program

;; @generated by Idris 0.7.0, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx tarm64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.dylib")

(let ()
(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work)])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))


(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PrimIO-prim__nullAnyPtr (lambda (farg-0) ((foreign-procedure "idris2_isNull" (void*) int) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__writeLine (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_writeLine" (void* string) int) farg-0 farg-1)))
(define SystemC-45FileC-45Error-prim__fileErrno (lambda (farg-0) ((foreign-procedure "idris2_fileErrno" () int) )))
(define SystemC-45FileC-45Handle-prim__open (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_openFile" (string string) void*) farg-0 farg-1)))
(define SystemC-45FileC-45Handle-prim__close (lambda (farg-0 farg-1) ((foreign-procedure "idris2_closeFile" (void*) void) farg-0)))
(define SystemC-45Random-prim__randomDouble (lambda (farg-0) (blodwen-random )))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-2 (arg-3 ext-0))) (arg-2 act-2))))
(define csegen-34 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8885) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-8885 eta-0)))))) (lambda (u--a) (lambda (arg-9931) (lambda (eta-0) arg-9931))) (lambda (u--b) (lambda (u--a) (lambda (arg-9937) (lambda (arg-9944) (lambda (world-4) (let ((act-5 (arg-9937 world-4))) (let ((act-3 (arg-9944 world-4))) (act-5 act-3))))))))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define PreludeC-45Types-u--foldlM_Foldable_List (lambda (arg-3 arg-4 arg-5 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define PreludeC-45Types-u--null_Foldable_List (lambda (arg-1) (if (null? arg-1) 1 0)))
(define csegen-52 (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10911) (PreludeC-45Types-u--null_Foldable_List arg-10911))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_List i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10940) arg-10940)) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10954) (PreludeC-45Types-u--foldMap_Foldable_List i_con-0 u--f arg-10954))))))))
(define csegen-60 (cons 3 (cons 0 '())))
(define ControlC-45LinearC-45LIO-u--bindL_LinearBind_IO (lambda (ext-0 ext-1 ext-2) (let ((act-3 (ext-0 ext-2))) ((ext-1 act-3) ext-2))))
(define csegen-83 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (lambda (eta-4) (ControlC-45LinearC-45LIO-u--bindL_LinearBind_IO eta-2 eta-3 eta-4)))))))
(define csegen-84 (cons (cons 1.0 0.0) '()))
(define csegen-85 (cons csegen-84 '()))
(define csegen-93 (vector csegen-34 (lambda (u--b) (lambda (u--a) (lambda (arg-10411) (lambda (arg-10414) (lambda (world-0) (let ((act-1 (arg-10411 world-0))) ((arg-10414 act-1) world-0))))))) (lambda (u--a) (lambda (arg-10425) (lambda (world-0) (let ((act-1 (arg-10425 world-0))) (act-1 world-0)))))))
(define csegen-96 (cons csegen-93 (lambda (u--a) (lambda (arg-13095) arg-13095))))
(define csegen-113 (lambda (eta-0) (lambda (eta-1) (cons eta-0 eta-1))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define PreludeC-45Show-u--show_Show_Nat (lambda (arg-0) (PreludeC-45Show-u--show_Show_Integer arg-0)))
(define PreludeC-45Show-u--showPrec_Show_Nat (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_Nat arg-1)))
(define csegen-134 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_Nat u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_Nat u--d u--x)))))
(define UnitaryLinear-HGate (vector 1 0 1 (vector 0 )))
(define UnitaryLinear-S (lambda (arg-1 arg-2 arg-3) (vector 2 (/ 3.141592653589793 2.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-SGate (UnitaryLinear-S 0 1 (vector 0 )))
(define UnitaryLinear-compose (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((0) arg-2) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (vector 1 e-2 e-3 (UnitaryLinear-compose e-4 arg-2)))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (vector 2 e-6 e-7 e-8 (UnitaryLinear-compose e-9 arg-2))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (vector 3 e-11 e-12 e-13 e-14 e-15 (UnitaryLinear-compose e-16 arg-2))))))))))))
(define csegen-138 (UnitaryLinear-compose UnitaryLinear-HGate UnitaryLinear-SGate))
(define Lemmas-ltz1 1)
(define csegen-153 (cons (vector 0 Lemmas-ltz1) '()))
(define csegen-157 (cons (cons 0.0 0.0) csegen-84))
(define csegen-158 (cons (cons 0.0 0.0) '()))
(define csegen-159 (cons (cons 1.0 0.0) csegen-158))
(define csegen-162 (cons (cons 0.0 0.0) csegen-158))
(define csegen-167 (cons (/ 1.0 (flsqrt 2.0)) 0.0))
(define Lemmas-lemma1LTESucc (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-lemma1LTESucc e-0))))))
(define csegen-178 (vector 1 0 (Lemmas-lemma1LTESucc 1) (vector 0 )))
(define csegen-212 (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 )))
(define csegen-227 (lambda (u--ret) (lambda (eta-0) (cons eta-0 u--ret))))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define UnitaryLinear-addSymbol (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) '() (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (let ((e-7 (car arg-4))) (let ((e-8 (cdr arg-4))) (cons (string-append e-7 e-3) (UnitaryLinear-addSymbol 0 1 (cons e-3 e-4) e-8))))))) (else (let ((e-11 (car arg-3))) (let ((e-12 (cdr arg-3))) (let ((e-15 (car arg-4))) (let ((e-16 (cdr arg-4))) (cons (string-append e-15 e-12) (UnitaryLinear-addSymbol 0 1 (cons e-11 e-12) e-16)))))))))(else (let ((e-0 (- arg-1 1))) (let ((e-19 (car arg-3))) (let ((e-20 (cdr arg-3))) (let ((e-23 (car arg-4))) (let ((e-24 (cdr arg-4))) (cons (string-append e-23 e-20) (UnitaryLinear-addSymbol e-0 0 (cons e-19 e-20) e-24))))))))))))
(define UnitaryLinear-addSymbolCNOT (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) '() (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 0) (cond ((equal? e-3 0) (cond ((equal? arg-2 0) (if (null? arg-4) (cond ((equal? arg-3 0) (if (null? arg-4) (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))) (let ((e-12 (car arg-4))) (let ((e-13 (cdr arg-4))) (cons (string-append e-12 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) arg-2 1 e-13))))))(else (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))))) (let ((e-16 (car arg-4))) (let ((e-17 (cdr arg-4))) (cons (string-append e-16 "- \x2022; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 arg-3 e-17))))))(else (cond ((equal? arg-3 0) (if (null? arg-4) (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))) (let ((e-12 (car arg-4))) (let ((e-13 (cdr arg-4))) (cons (string-append e-12 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons 0 0) arg-2 1 e-13))))))(else (cond (else (cond (else (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (string-append e-8 "-----") (UnitaryLinear-addSymbolCNOT (cons 0 0) 1 1 e-9)))))))))))))(else (let ((e-5 (- e-3 1))) (cond ((equal? arg-2 0) (let ((e-20 (car arg-4))) (let ((e-21 (cdr arg-4))) (cons (string-append e-20 "- \x2022; -") (UnitaryLinear-addSymbolCNOT (cons 0 e-5) 1 arg-3 e-21))))) (else (let ((e-24 (car arg-4))) (let ((e-25 (cdr arg-4))) (cons (string-append e-24 "--|--") (UnitaryLinear-addSymbolCNOT (cons 0 e-5) 1 0 e-25))))))))))(else (let ((e-4 (- e-2 1))) (cond ((equal? e-3 0) (cond ((equal? arg-3 0) (let ((e-29 (car arg-4))) (let ((e-30 (cdr arg-4))) (cons (string-append e-29 "- \x398; -") (UnitaryLinear-addSymbolCNOT (cons e-4 0) arg-2 1 e-30))))) (else (let ((e-33 (car arg-4))) (let ((e-34 (cdr arg-4))) (cons (string-append e-33 "--|--") (UnitaryLinear-addSymbolCNOT (cons e-4 0) 0 1 e-34)))))))(else (let ((e-26 (- e-3 1))) (let ((e-37 (car arg-4))) (let ((e-38 (cdr arg-4))) (cons (string-append e-37 "-----") (UnitaryLinear-addSymbolCNOT (cons e-4 e-26) 0 0 e-38)))))))))))))))
(define UnitaryLinear-drawWirePhase (lambda (arg-0) (cond ((equal? arg-0 0) "")(else (let ((e-0 (- arg-0 1))) (string-append "-" (UnitaryLinear-drawWirePhase e-0)))))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45TypesC-45String-length (lambda (arg-0) (PreludeC-45Types-prim__integerToNat (string-length arg-0))))
(define UnitaryLinear-newWireQVect (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons "" (UnitaryLinear-newWireQVect e-0)))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (<= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (>= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-u--showPrec_Show_Double (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Double (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Double (vector 0 ) arg-0)))
(define UnitaryLinear-printPhase (lambda (arg-0 arg-1 arg-2) (let ((sc0 (let ((sc1 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- 3.141592653589793 arg-1)))) (cond ((equal? sc1 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ 3.141592653589793 arg-1))) (else 0))))) (cond ((equal? sc0 1) arg-2) (else (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 2.0) arg-1)))) (cond ((equal? sc2 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 2.0) arg-1))) (else 0))))) (cond ((equal? sc1 1) (string-append arg-2 "/2")) (else (let ((sc2 (let ((sc3 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 3.0) arg-1)))) (cond ((equal? sc3 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 3.0) arg-1))) (else 0))))) (cond ((equal? sc2 1) (string-append arg-2 "/3")) (else (let ((sc3 (let ((sc4 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 4.0) arg-1)))) (cond ((equal? sc4 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 4.0) arg-1))) (else 0))))) (cond ((equal? sc3 1) (string-append arg-2 "/4")) (else (let ((sc4 (let ((sc5 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 6.0) arg-1)))) (cond ((equal? sc5 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 6.0) arg-1))) (else 0))))) (cond ((equal? sc4 1) (string-append arg-2 "/6")) (else (let ((sc5 (let ((sc6 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ 3.141592653589793 8.0) arg-1)))) (cond ((equal? sc6 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ 3.141592653589793 8.0) arg-1))) (else 0))))) (cond ((equal? sc5 1) (string-append arg-2 "/8")) (else (let ((sc6 (let ((sc7 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (- 3.141592653589793) arg-1)))) (cond ((equal? sc7 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (- 3.141592653589793) arg-1))) (else 0))))) (cond ((equal? sc6 1) (string-append "-" arg-2)) (else (let ((sc7 (let ((sc8 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 2.0) arg-1)))) (cond ((equal? sc8 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 2.0) arg-1))) (else 0))))) (cond ((equal? sc7 1) (string-append "-" (string-append arg-2 "/2"))) (else (let ((sc8 (let ((sc9 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 3.0) arg-1)))) (cond ((equal? sc9 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 3.0) arg-1))) (else 0))))) (cond ((equal? sc8 1) (string-append "-" (string-append arg-2 "/3"))) (else (let ((sc9 (let ((sc10 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 4.0) arg-1)))) (cond ((equal? sc10 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 4.0) arg-1))) (else 0))))) (cond ((equal? sc9 1) (string-append "-" (string-append arg-2 "/4"))) (else (let ((sc10 (let ((sc11 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 6.0) arg-1)))) (cond ((equal? sc11 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 6.0) arg-1))) (else 0))))) (cond ((equal? sc10 1) (string-append "-" (string-append arg-2 "/6"))) (else (let ((sc11 (let ((sc12 (PreludeC-45EqOrd-u--C-62C-61_Ord_Double arg-0 (- (/ (- 3.141592653589793) 8.0) arg-1)))) (cond ((equal? sc12 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Double arg-0 (+ (/ (- 3.141592653589793) 8.0) arg-1))) (else 0))))) (cond ((equal? sc11 1) (string-append "-" (string-append arg-2 "/8"))) (else (PreludeC-45Show-u--show_Show_Double arg-0)))))))))))))))))))))))))))))))))))))))
(define UnitaryLinear-drawGate (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (UnitaryLinear-newWireQVect arg-0)) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-4 (vector-ref arg-1 3))) (UnitaryLinear-addSymbol e-2 0 (cons "- H -" "-----") (UnitaryLinear-drawGate arg-0 e-4))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-9 (vector-ref arg-1 4))) (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ 3.141592653589793 4.0) 0.001) e-6))) (cond ((equal? sc2 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ 3.141592653589793 4.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc1 1) (UnitaryLinear-addSymbol e-7 0 (cons "- T -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc2 (let ((sc3 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ (- 3.141592653589793) 4.0) 0.001) e-6))) (cond ((equal? sc3 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ (- 3.141592653589793) 4.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc2 1) (UnitaryLinear-addSymbol e-7 0 (cons "- T+ -" "------") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc3 (let ((sc4 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ 3.141592653589793 2.0) 0.001) e-6))) (cond ((equal? sc4 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ 3.141592653589793 2.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc3 1) (UnitaryLinear-addSymbol e-7 0 (cons "- S -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc4 (let ((sc5 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- (/ (- 3.141592653589793) 2.0) 0.001) e-6))) (cond ((equal? sc5 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ (/ (- 3.141592653589793) 2.0) 0.001) e-6)) (else 0))))) (cond ((equal? sc4 1) (UnitaryLinear-addSymbol e-7 0 (cons "- S+ -" "------") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((sc5 (let ((sc6 (PreludeC-45EqOrd-u--C-60C-61_Ord_Double (- 3.141592653589793 0.001) e-6))) (cond ((equal? sc6 1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double (+ 3.141592653589793 0.001) e-6)) (else 0))))) (cond ((equal? sc5 1) (UnitaryLinear-addSymbol e-7 0 (cons "- Z -" "-----") (UnitaryLinear-drawGate arg-0 e-9))) (else (let ((u--s (UnitaryLinear-printPhase e-6 0.001 "\x3c0;"))) (UnitaryLinear-addSymbol e-7 0 (cons (string-append "- P(" (string-append u--s ") -")) (UnitaryLinear-drawWirePhase (+ (PreludeC-45TypesC-45String-length u--s) 7))) (UnitaryLinear-drawGate arg-0 e-9)))))))))))))))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-16 (vector-ref arg-1 6))) (UnitaryLinear-addSymbolCNOT (cons e-11 e-12) 0 0 (UnitaryLinear-drawGate arg-0 e-16)))))))))
(define UnitaryLinear-drawVect (lambda (arg-1) (if (null? arg-1) "" (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (string-append e-3 (string-append "\xa;" (UnitaryLinear-drawVect e-4))))))))
(define UnitaryLinear-draw (lambda (arg-0 arg-1) (let ((u--vs1 (UnitaryLinear-drawGate arg-0 arg-1))) (let ((u--s (UnitaryLinear-drawVect u--vs1))) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append u--s "\xa;") eta-0))))))
(define Lemmas-lemmaLTSucc (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (+ (Lemmas-lemmaLTSucc e-0) 1))))))
(define Lemmas-lemmakLTSk (lambda (arg-0) (+ (Lemmas-lemmaLTSucc arg-0) 1)))
(define Lemmas-eitherLTtoSucc (lambda (arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 0 (+ e-2 1)))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 1 (+ e-5 1)))))))
(define Lemmas-ltzs (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-ltzs e-0))))))
(define Lemmas-lemmaDiffSuccPlusE (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 (Lemmas-ltzs arg-1)))(else (let ((e-0 (- arg-0 1))) (Lemmas-eitherLTtoSucc (Lemmas-lemmaDiffSuccPlusE e-0 arg-1)))))))
(define Lemmas-isDiffRangeVect (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Lemmas-lemmaDiffSuccPlusE arg-0 arg-2) (Lemmas-isDiffRangeVect arg-0 e-0 (+ arg-2 1))))))))
(define Lemmas-allDiffRangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (let ((u--p1 (Lemmas-isDiffRangeVect arg-0 e-0 0))) (cons u--p1 (Lemmas-allDiffRangeVect (+ arg-0 1) e-0))))))))
(define Injection-lteTransitive (lambda (arg-3 arg-4) (cond ((equal? arg-3 0) 0)(else (let ((e-3 (- arg-3 1))) (cond ((equal? arg-4 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-6 (- arg-4 1))) (+ (Injection-lteTransitive e-3 e-6) 1)))))))))
(define Injection-plusLT (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) arg-3)(else (Injection-lteTransitive arg-3 arg-1)))))
(define Injection-ifAllSmallThenPlusSmall (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-1) (if (null? arg-4) '() (cond ((equal? arg-3 0) arg-4)(else (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-4 (- arg-3 1))) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (cons (Injection-plusLT e-2 arg-2 (+ e-4 1) e-9) (Injection-ifAllSmallThenPlusSmall e-3 arg-2 (+ e-4 1) e-10)))))))))))) (cond ((equal? arg-3 0) arg-4)(else (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-3 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-4 (- arg-3 1))) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (cons (Injection-plusLT e-2 arg-2 (+ e-4 1) e-9) (Injection-ifAllSmallThenPlusSmall e-3 arg-2 (+ e-4 1) e-10))))))))))))))
(define Lemmas-allSmallerPlus (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-3) '() (Injection-ifAllSmallThenPlusSmall arg-3 arg-1 arg-2 arg-4))))
(define DataC-45Nat-fromLteSucc (lambda (arg-2) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-2 (- arg-2 1))) e-2)))))
(define Lemmas-lemmaLTSuccPlus (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else (let ((e-1 (- arg-1 1))) (DataC-45Nat-fromLteSucc (+ (Lemmas-lemmaLTSuccPlus 0 e-1) 1))))))(else (let ((e-0 (- arg-0 1))) (+ (Lemmas-lemmaLTSuccPlus e-0 arg-1) 1))))))
(define Lemmas-allSmallerRangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Lemmas-lemmaLTSuccPlus arg-0 e-0) (Lemmas-allSmallerRangeVect (+ arg-0 1) e-0)))))))
(define PreludeC-45Uninhabited-void (lambda (ext-0) (display "Error: Executed 'void'")))
(define PreludeC-45Uninhabited-absurd (lambda (arg-2 arg-3) (PreludeC-45Uninhabited-void 'erased)))
(define Injection-allDiffToPrf (lambda (arg-3) (let ((e-3 (car arg-3))) e-3)))
(define Injection-ifDiffThenSubDiff (lambda (arg-4) (let ((e-5 (cdr arg-4))) e-5)))
(define Injection-isDiffToPrf (lambda (arg-4) (let ((e-4 (car arg-4))) e-4)))
(define Lemmas-differentC-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-2 0) (Injection-isDiffToPrf arg-5))(else (let ((e-0 (- arg-2 1))) (let ((e-8 (cdr arg-3))) (Lemmas-differentC-39 arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4) (Injection-ifDiffThenSubDiff arg-5))))))))
(define Lemmas-mirror (lambda (arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 1 e-2))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 0 e-5))))))
(define Lemmas-differentC-39C-39 (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-2 0) (Lemmas-mirror (Injection-isDiffToPrf arg-5)))(else (let ((e-0 (- arg-2 1))) (let ((e-8 (cdr arg-3))) (Lemmas-differentC-39C-39 arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4) (Injection-ifDiffThenSubDiff arg-5))))))))
(define Lemmas-eitherLTSucc (lambda (arg-0 arg-1 arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 0 (DataC-45Nat-fromLteSucc e-2)))) (else (let ((e-5 (vector-ref arg-2 1))) (vector 1 (DataC-45Nat-fromLteSucc e-5)))))))
(define Injection-getAllDifferent (lambda (arg-3) (let ((e-3 (car arg-3))) e-3)))
(define Injection-ifAllDiffThenSubDiff (lambda (arg-3) (let ((e-4 (cdr arg-3))) e-4)))
(define Injection-ifAllSmallThenSubSmall (lambda (arg-4) (let ((e-5 (cdr arg-4))) e-5)))
(define Injection-ifInjectiveThenSubInjective (lambda (arg-4) (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (cons (Injection-ifAllDiffThenSubDiff e-3) (Injection-ifAllSmallThenSubSmall e-4))))))
(define PreludeC-45Types-u--uninhabited_Uninhabited_C-40C-40EitherC-32C-36aC-41C-32C-36bC-41 (lambda (arg-2 arg-3 arg-4) (case (vector-ref arg-4 0) ((0) (let ((e-2 (vector-ref arg-4 1))) (arg-2 e-2))) (else (let ((e-5 (vector-ref arg-4 1))) (arg-3 e-5))))))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define Lemmas-differentIndexInjectiveVect (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (PreludeC-45Uninhabited-absurd (lambda (eta-0) (PreludeC-45Types-u--uninhabited_Uninhabited_C-40C-40EitherC-32C-36aC-41C-32C-36bC-41 (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 eta-1)) (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-40LTEC-32C-40SC-32C-36nC-41C-41C-32ZC-41 eta-1)) eta-0)) arg-4))(else (let ((e-1 (- arg-2 1))) (let ((e-4 (car arg-5))) (let ((e-5 (cdr arg-5))) (Lemmas-differentC-39 e-4 e-1 e-5 (DataC-45Nat-fromLteSucc arg-8) (Injection-allDiffToPrf (Injection-getAllDifferent arg-6)))))))))(else (let ((e-0 (- arg-1 1))) (cond ((equal? arg-2 0) (let ((e-9 (car arg-5))) (let ((e-10 (cdr arg-5))) (Lemmas-differentC-39C-39 e-9 e-0 e-10 (DataC-45Nat-fromLteSucc arg-7) (Injection-allDiffToPrf (Injection-getAllDifferent arg-6))))))(else (let ((e-6 (- arg-2 1))) (let ((e-14 (cdr arg-5))) (Lemmas-differentIndexInjectiveVect e-0 e-6 arg-3 (Lemmas-eitherLTSucc e-0 e-6 arg-4) e-14 (Injection-ifInjectiveThenSubInjective arg-6) (DataC-45Nat-fromLteSucc arg-7) (DataC-45Nat-fromLteSucc arg-8)))))))))))
(define Injection-getAllSmaller (lambda (arg-3) (let ((e-4 (cdr arg-3))) e-4)))
(define Injection-getPrfSmaller (lambda (arg-3) (let ((e-4 (car arg-3))) e-4)))
(define Lemmas-indexInjectiveVect (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-1 0) (Injection-getPrfSmaller (Injection-getAllSmaller arg-4)))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-3))) (Lemmas-indexInjectiveVect e-0 arg-2 e-8 (Injection-ifInjectiveThenSubInjective arg-4) (DataC-45Nat-fromLteSucc arg-5))))))))
(define Injection-indexLT (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (let ((e-3 (car arg-2))) e-3))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-2))) (Injection-indexLT e-0 e-8 (DataC-45Nat-fromLteSucc arg-3))))))))
(define UnitaryLinear-apply (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (case (vector-ref arg-2 0) ((0) arg-3) ((1) (let ((e-2 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 2))) (let ((e-4 (vector-ref arg-2 3))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect e-2 arg-1 arg-4 arg-5 eta-0)))) (vector 1 (Injection-indexLT e-2 arg-4 e-3) (u--prf1 e-3) (UnitaryLinear-apply arg-0 arg-1 e-4 arg-3 arg-4 arg-5))))))) ((2) (let ((e-6 (vector-ref arg-2 1))) (let ((e-7 (vector-ref arg-2 2))) (let ((e-8 (vector-ref arg-2 3))) (let ((e-9 (vector-ref arg-2 4))) (let ((u--prf1 (lambda (eta-0) (Lemmas-indexInjectiveVect e-7 arg-1 arg-4 arg-5 eta-0)))) (vector 2 e-6 (Injection-indexLT e-7 arg-4 e-8) (u--prf1 e-8) (UnitaryLinear-apply arg-0 arg-1 e-9 arg-3 arg-4 arg-5)))))))) (else (let ((e-11 (vector-ref arg-2 1))) (let ((e-12 (vector-ref arg-2 2))) (let ((e-13 (vector-ref arg-2 3))) (let ((e-14 (vector-ref arg-2 4))) (let ((e-15 (vector-ref arg-2 5))) (let ((e-16 (vector-ref arg-2 6))) (let ((u--prf4 (lambda (eta-0) (Lemmas-indexInjectiveVect e-11 arg-1 arg-4 arg-5 eta-0)))) (let ((u--prf5 (lambda (eta-0) (Lemmas-indexInjectiveVect e-12 arg-1 arg-4 arg-5 eta-0)))) (let ((u--prf6 (Lemmas-differentIndexInjectiveVect e-11 e-12 arg-1 e-15 arg-4 arg-5 e-13 e-14))) (vector 3 (Injection-indexLT e-11 arg-4 e-13) (Injection-indexLT e-12 arg-4 e-14) (u--prf4 e-13) (u--prf5 e-14) u--prf6 (UnitaryLinear-apply arg-0 arg-1 e-16 arg-3 arg-4 arg-5)))))))))))))))
(define Lemmas-isInjectiveRangeVect (lambda (arg-0 arg-1) (cons (Lemmas-allDiffRangeVect arg-0 arg-1) (Lemmas-allSmallerRangeVect arg-0 arg-1))))
(define Injection-rangeVect (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons arg-0 (Injection-rangeVect (+ arg-0 1) e-0)))))))
(define UnitaryLinear-tensor (lambda (arg-0 arg-1 arg-2 arg-3) (let ((u--p1 (Lemmas-allSmallerRangeVect 0 arg-0))) (let ((u--p2 (Lemmas-isInjectiveRangeVect arg-0 arg-1))) (let ((u--p3 (Lemmas-allSmallerPlus arg-0 arg-1 (Injection-rangeVect 0 arg-0) u--p1))) (let ((u--p4 (cons (Lemmas-allDiffRangeVect 0 arg-0) u--p3))) (UnitaryLinear-apply arg-1 (+ arg-0 arg-1) arg-3 (UnitaryLinear-apply arg-0 (+ arg-0 arg-1) arg-2 (vector 0 ) (Injection-rangeVect 0 arg-0) u--p4) (Injection-rangeVect arg-0 arg-1) u--p2)))))))
(define VQE-encodingUnitary (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 ))(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (cond ((equal? e-4 0) (UnitaryLinear-tensor (+ e-0 1) 1 (VQE-encodingUnitary e-0 e-5) (vector 0 ))) ((equal? e-4 1) (let ((u--p1 (Lemmas-lemmakLTSk e-0))) (vector 3 (+ e-0 1) 0 u--p1 (Lemmas-lemma1LTESucc (+ e-0 1)) (vector 1 (Lemmas-lemma1LTESucc e-0)) (vector 1 (+ e-0 1) u--p1 (UnitaryLinear-tensor (+ e-0 1) 1 (VQE-encodingUnitary e-0 e-5) (vector 0 )))))) ((equal? e-4 2) (let ((u--p1 (Lemmas-lemmakLTSk e-0))) (vector 3 (+ e-0 1) 0 u--p1 (Lemmas-lemma1LTESucc (+ e-0 1)) (vector 1 (Lemmas-lemma1LTESucc e-0)) (vector 1 (+ e-0 1) u--p1 (UnitaryLinear-tensor (+ e-0 1) 1 (VQE-encodingUnitary e-0 e-5) (vector 0 )))))) (else (let ((u--p1 (Lemmas-lemmakLTSk e-0))) (vector 3 (+ e-0 1) 0 u--p1 (Lemmas-lemma1LTESucc (+ e-0 1)) (vector 1 (Lemmas-lemma1LTESucc e-0)) (UnitaryLinear-tensor (+ e-0 1) 1 (VQE-encodingUnitary e-0 e-5) (vector 0 )))))))))))))
(define Main-encodingTestU (lambda () (let ((u--p csegen-60)) (VQE-encodingUnitary 2 u--p))))
(define UnitaryLinear-unitarytoQiskit (lambda (arg-1) (case (vector-ref arg-1 0) ((0) "") ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-4 (vector-ref arg-1 3))) (string-append (UnitaryLinear-unitarytoQiskit e-4) (string-append "qc.h(qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-2) "])\xa;qc.barrier(qr)\xa;")))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-9 (vector-ref arg-1 4))) (string-append (UnitaryLinear-unitarytoQiskit e-9) (string-append "qc.p(" (string-append (UnitaryLinear-printPhase e-6 0.001 "np.pi") (string-append ", qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-7) "])\xa;qc.barrier(qr)\xa;"))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-16 (vector-ref arg-1 6))) (string-append (UnitaryLinear-unitarytoQiskit e-16) (string-append "qc.cx(qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-11) (string-append "], qr[" (string-append (PreludeC-45Show-u--show_Show_Nat e-12) "])\xa;qc.barrier(qr)\xa;"))))))))))))
(define UnitaryLinear-toQiskit (lambda (arg-0 arg-1) (let ((u--s (UnitaryLinear-unitarytoQiskit arg-1))) (string-append "import numpy as np\xa;" (string-append "from qiskit import QuantumCircuit\xa;" (string-append "from qiskit import QuantumRegister\xa;" (string-append "qr = QuantumRegister(" (string-append (PreludeC-45Show-u--show_Show_Nat arg-0) (string-append ")\xa;" (string-append "qc = QuantumCircuit(qr)\xa;\xa;" (string-append u--s "\xa;print(qc)")))))))))))
(define SystemC-45FileC-45Support-ok (lambda (arg-3 arg-4) (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) (vector 1 arg-4)))))))
(define SystemC-45FileC-45Error-returnError (lambda (arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Error-prim__fileErrno eta-0))))) (lambda (u--err) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (vector 0 (cond ((equal? u--err 0) (vector 1 )) ((equal? u--err 1) (vector 2 )) ((equal? u--err 2) (vector 3 )) ((equal? u--err 3) (vector 4 )) ((equal? u--err 4) (vector 5 ))(else (vector 0 (bs- u--err 5 63)))))))))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define SystemC-45FileC-45ReadWrite-fPutStr (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__writeLine arg-2 arg-3 eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--res (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 (vector 0 )))))))))))
(define SystemC-45FileC-45Handle-closeFile (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__close arg-2 eta-0))))))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) 1) (else arg-1))))
(define PreludeC-45Types-elemBy (lambda (arg-2 arg-3 arg-4 ext-0) (let ((e-6 (vector-ref arg-2 5))) (((((e-6 'erased) 'erased) (cons (lambda (arg-8474) (lambda (arg-8477) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool arg-8474 arg-8477))) 0)) (arg-3 arg-4)) ext-0))))
(define PreludeC-45Types-elem (lambda (arg-2 arg-3 ext-1 ext-0) (PreludeC-45Types-elemBy arg-2 (lambda (eta-0) (lambda (eta-1) (let ((e-1 (car arg-3))) ((e-1 eta-0) eta-1)))) ext-1 ext-0)))
(define SystemC-45Info-os (blodwen-os))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45Info-isWindows (PreludeC-45Types-elem csegen-52 (cons (lambda (arg-676) (lambda (arg-679) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-676 arg-679))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-686 arg-689)))) SystemC-45Info-os (cons "windows" (cons "mingw32" (cons "cygwin32" '())))))
(define SystemC-45FileC-45Mode-modeStr (lambda (arg-0) (cond ((equal? arg-0 0) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb") (else "r")))) ((equal? arg-0 1) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb") (else "w")))) ((equal? arg-0 2) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab") (else "a")))) ((equal? arg-0 3) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb+") (else "r+")))) ((equal? arg-0 4) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb+") (else "w+")))) (else (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab+") (else "a+")))))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45FileC-45Handle-openFile (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__open arg-2 (SystemC-45FileC-45Mode-modeStr arg-3) eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr u--res) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 u--res))))))))))
(define SystemC-45FileC-45Handle-withFile (lambda (arg-3 arg-4 arg-5 arg-6 arg-7) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FileC-45Handle-openFile arg-3 arg-4 arg-5)) (lambda (_-0) (case (vector-ref _-0 0) ((1) (let ((e-6 (vector-ref _-0 1))) (let ((e-8 (car arg-3))) (let ((e-10 (vector-ref e-8 1))) ((((e-10 'erased) 'erased) (arg-7 e-6)) (lambda (u--res) (let ((e-13 (car arg-3))) (let ((e-15 (vector-ref e-13 1))) ((((e-15 'erased) 'erased) (SystemC-45FileC-45Handle-closeFile arg-3 e-6)) (lambda (_-10649) (let ((e-18 (car arg-3))) (let ((e-21 (vector-ref e-18 0))) (let ((e-23 (vector-ref e-21 1))) ((e-23 'erased) u--res)))))))))))))) (else (let ((e-6 (vector-ref _-0 1))) (let ((e-8 (car arg-3))) (let ((e-11 (vector-ref e-8 0))) (let ((e-14 (vector-ref e-11 0))) ((((e-14 'erased) 'erased) (lambda (eta-0) (vector 0 eta-0))) (arg-6 e-6))))))))))))))
(define SystemC-45FileC-45ReadWrite-writeFile (lambda (arg-1 arg-2 arg-3) (SystemC-45FileC-45Handle-withFile arg-1 arg-2 1 (lambda (eta-0) (let ((e-1 (car arg-1))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) eta-0))))) (lambda (eta-0) (PreludeC-45Basics-flip (lambda (eta-1) (lambda (eta-2) (SystemC-45FileC-45ReadWrite-fPutStr arg-1 eta-1 eta-2))) arg-3 eta-0)))))
(define UnitaryLinear-exportToQiskit (lambda (arg-0 arg-1 arg-2) (let ((u--s (UnitaryLinear-toQiskit arg-0 arg-2))) (lambda (world-0) (let ((act-1 ((SystemC-45FileC-45ReadWrite-writeFile csegen-96 arg-1 u--s) world-0))) (case (vector-ref act-1 0) ((0) (PreludeC-45IO-prim__putStr "Error when writing file\xa;" world-0)) (else (vector 0 ))))))))
(define Main-case--encodingTestIo-10081 (lambda (arg-0 ext-0) (let ((e-2 (car arg-0))) (let ((act-1 ((UnitaryLinear-exportToQiskit 3 "encodingstupid.py" e-2) ext-0))) (let ((act-2 ((UnitaryLinear-draw 3 e-2) ext-0))) (let ((act-3 ((UnitaryLinear-draw 3 (Main-encodingTestU)) ext-0))) (vector 0 )))))))
(define QStateT-C-62C-62C-61 (lambda (arg-5 arg-6 ext-0) (vector 4 1 (arg-5 ext-0) (lambda (lamc-0) (let ((e-2 (car lamc-0))) (let ((e-3 (cdr lamc-0))) ((arg-6 e-3) e-2)))))))
(define QStateT-pure (lambda (arg-2 ext-0) (vector 1 (cons ext-0 arg-2))))
(define CoinToss-coin (lambda (arg-1 arg-2 ext-0) (let ((act-1 (let ((e-9 (vector-ref arg-2 8))) (((e-9 1) (lambda (eta-0) (QStateT-C-62C-62C-61 (let ((e-17 (vector-ref arg-2 1))) (e-17 'erased)) (lambda (u--q) (lambda (eta-1) (QStateT-C-62C-62C-61 (let ((e-16 (vector-ref arg-2 2))) (((e-16 1) 1) (let ((e-25 (vector-ref arg-1 3))) ((e-25 1) u--q)))) (lambda (q-0) (lambda (eta-2) (QStateT-C-62C-62C-61 (let ((e-13 (vector-ref arg-2 5))) (((e-13 0) 1) q-0)) (lambda (u--r) (lambda (eta-3) (QStateT-pure u--r eta-3))) eta-2))) eta-1))) eta-0))) ext-0)))) (let ((e-2 (car act-1))) (let ((e-3 (cdr act-1))) e-2)))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define PreludeC-45TypesC-45List-lengthPlus (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-lengthPlus (+ arg-1 1) e-3)))))
(define PreludeC-45TypesC-45List-lengthTR (lambda (ext-0) (PreludeC-45TypesC-45List-lengthPlus 0 ext-0)))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define DataC-45List-replicateTR (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) arg-1)(else (let ((e-0 (- arg-2 1))) (DataC-45List-replicateTR (cons arg-3 arg-1) e-0 arg-3))))))
(define PreludeC-45Interfaces-sequence (lambda (arg-3 arg-4 ext-0) (let ((e-3 (vector-ref arg-4 2))) ((((((e-3 'erased) 'erased) 'erased) arg-3) (lambda (eta-0) eta-0)) ext-0))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Bool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0)))(else 0))))
(define UnitaryLinear-adjoint (lambda (arg-1) (case (vector-ref arg-1 0) ((0) (vector 0 )) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-4) (vector 1 e-2 e-3 (vector 0 ))))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-9) (vector 2 (- e-6) e-7 e-8 (vector 0 )))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (UnitaryLinear-compose (UnitaryLinear-adjoint e-16) (vector 3 e-11 e-12 e-13 e-14 e-15 (vector 0 )))))))))))))
(define Matrix-ket1 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons (cons (cons 1.0 0.0) csegen-84) (Matrix-ket1 e-0)))))))
(define DataC-45Vect-C-43C-43 (lambda (arg-3 arg-4) (if (null? arg-3) arg-4 (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons e-3 (DataC-45Vect-C-43C-43 e-4 arg-4)))))))
(define Matrix-concatCols (lambda (arg-3 arg-4) (DataC-45Vect-C-43C-43 arg-3 arg-4)))
(define Matrix-concatRows (lambda (arg-3 arg-4) (if (null? arg-3) '() (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (cons (DataC-45Vect-C-43C-43 e-3 e-8) (Matrix-concatRows e-4 e-9)))))))))
(define Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 (lambda (arg-0 arg-1) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (cons (- (* e-1 e-4) (* e-2 e-5)) (+ (* e-2 e-4) (* e-1 e-5)))))))))
(define Matrix-multScalarVect (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (cons (Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 arg-1 e-3) (Matrix-multScalarVect arg-1 e-4)))))))
(define Matrix-multScalarMatrix (lambda (arg-2 arg-3) (if (null? arg-3) '() (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons (Matrix-multScalarVect arg-2 e-3) (Matrix-multScalarMatrix arg-2 e-4)))))))
(define Matrix-tensorProductC-39 (lambda (arg-3 arg-4) (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (if (null? e-3) (Matrix-multScalarMatrix e-2 arg-4) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (Matrix-concatRows (Matrix-multScalarMatrix e-2 arg-4) (Matrix-tensorProductC-39 (cons e-7 e-8) arg-4)))))))))
(define Matrix-tensorProduct (lambda (arg-4 arg-5) (if (null? arg-4) '() (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (if (null? e-4) (Matrix-tensorProductC-39 e-3 arg-5) (let ((e-8 (car e-4))) (let ((e-9 (cdr e-4))) (Matrix-concatCols (Matrix-tensorProductC-39 e-3 arg-5) (Matrix-tensorProduct (cons e-8 e-9) arg-5))))))))))
(define Matrix-toTensorBasis (lambda (arg-1) (if (null? arg-1) csegen-85 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (let ((e-11 (car e-8))) (let ((e-12 (cdr e-8))) (Matrix-tensorProduct (cons (cons e-7 '()) (cons (cons e-11 '()) '())) (Matrix-toTensorBasis e-4)))))))))))
(define Matrix-neutralIdPow (lambda (arg-0) (Matrix-toTensorBasis (Matrix-ket1 arg-0))))
(define UnitaryOp-invert (lambda (arg-2 arg-3) (let ((e-0 (vector-ref arg-3 0))) (let ((e-1 (vector-ref arg-3 1))) (let ((e-2 (vector-ref arg-3 2))) (let ((e-3 (vector-ref arg-3 3))) (let ((e-4 (vector-ref arg-3 4))) (let ((sc0 (arg-2 (vector e-0 (Matrix-neutralIdPow e-0) (vector 0 ) e-3 e-4)))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-9 (vector-ref e-6 2))) (let ((u--invu (UnitaryLinear-adjoint e-9))) (let ((u--unew (UnitaryLinear-compose u--invu e-2))) (cons (vector e-0 e-1 u--unew e-3 e-4) e-5))))))))))))))
(define UnitaryOp-adjointUSTC-39 (lambda (arg-2 ext-0) (UnitaryOp-invert arg-2 ext-0)))
(define UnitaryOp-u--adjointUST_UnitaryOp_SimulatedOp (lambda (ext-1 ext-0) (UnitaryOp-adjointUSTC-39 ext-1 ext-0)))
(define UStateT-C-62C-62C-61 (lambda (arg-5 arg-6 ext-0) (let ((sc0 (arg-5 ext-0))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) ((arg-6 e-3) e-2))))))
(define UnitaryLinear-CNOTGate (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 0 )))
(define Qubit-distributeDupedLVectVect (lambda (arg-1) (if (null? arg-1) (cons '() '()) (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((sc1 (Qubit-distributeDupedLVectVect e-4))) (let ((e-2 (car sc1))) (let ((e-5 (cdr sc1))) (cons (cons e-3 e-2) (cons e-3 e-5))))))))))
(define Builtin-idris_crash (lambda (ext-0) (blodwen-error-quit (string-append "ERROR: " ext-0))))
(define DataC-45Nat-succNotLTEzero (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DataC-45Nat-isLTE (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 0))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (vector 1 (lambda (eta-0) (DataC-45Nat-succNotLTEzero eta-0))))(else (let ((e-1 (- arg-1 1))) (let ((sc0 (DataC-45Nat-isLTE e-0 e-1))) (case (vector-ref sc0 0) ((1) (let ((e-2 (vector-ref sc0 1))) (vector 1 (lambda (eta-0) (e-2 (DataC-45Nat-fromLteSucc eta-0)))))) (else (let ((e-3 (vector-ref sc0 1))) (vector 0 (+ e-3 1))))))))))))))
(define DataC-45Nat-isLT (lambda (arg-0 arg-1) (DataC-45Nat-isLTE (+ arg-0 1) arg-1)))
(define PreludeC-45Show-n--3221-12652-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define DataC-45Vect-foldrImpl (lambda (arg-3 arg-4 arg-5 arg-6) (if (null? arg-6) (arg-5 arg-4) (let ((e-3 (car arg-6))) (let ((e-4 (cdr arg-6))) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) (arg-5 ((arg-3 e-3) eta-0))) e-4))))))
(define DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4 arg-5) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) eta-0) arg-5)))
(define DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 (lambda (ext-0) (DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 csegen-113 '() ext-0)))
(define DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 (lambda (arg-2 ext-0) (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 arg-2 (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 ext-0))))
(define Injection-findProofIsDiffOrFail (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((sc1 (DataC-45Nat-isLT arg-1 e-3))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (cons (vector 0 e-1) (Injection-findProofIsDiffOrFail arg-1 e-4)))) (else (let ((sc2 (DataC-45Nat-isLT e-3 arg-1))) (case (vector-ref sc2 0) ((0) (let ((e-1 (vector-ref sc2 1))) (cons (vector 1 e-1) (Injection-findProofIsDiffOrFail arg-1 e-4)))) (else (Builtin-idris_crash (string-append "There exists no automatic proof that the Vector " (string-append (DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 csegen-134 (cons e-3 e-4)) (string-append " is Injective (not all different) " (string-append (PreludeC-45Show-u--show_Show_Nat arg-1) (string-append " is not different to " (PreludeC-45Show-u--show_Show_Nat e-3))))))))))))))))))
(define Injection-findProofAllDiffOrFail (lambda (arg-1) (if (null? arg-1) '() (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (cons (Injection-findProofIsDiffOrFail e-3 e-4) (Injection-findProofAllDiffOrFail e-4)))))))
(define Injection-findProofAllSmallerOrFail (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((sc1 (DataC-45Nat-isLT e-3 arg-1))) (case (vector-ref sc1 0) ((0) (let ((e-1 (vector-ref sc1 1))) (cons e-1 (Injection-findProofAllSmallerOrFail arg-1 e-4)))) (else (Builtin-idris_crash (string-append "There exists no automatic proof that the Vector " (string-append (DataC-45Vect-u--show_Show_C-40C-40VectC-32C-36lenC-41C-32C-36elemC-41 csegen-134 (cons e-3 e-4)) (string-append " is Injective (not all smaller): " (string-append (PreludeC-45Show-u--show_Show_Nat e-3) (string-append " is not smaller than " (PreludeC-45Show-u--show_Show_Nat arg-1)))))))))))))))
(define UnitaryOp-case--applyUnitaryC-39-3823 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (cons (vector arg-0 arg-5 (UnitaryLinear-apply arg-1 arg-0 arg-6 arg-4 e-3 (cons (Injection-findProofAllDiffOrFail e-3) (Injection-findProofAllSmallerOrFail arg-0 e-3))) arg-3 arg-2) e-2)))))
(define UnitaryOp-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (UnitaryOp-case--applyUnitaryC-39-3823 arg-0 arg-1 e-4 e-3 e-2 e-1 arg-3 (Qubit-distributeDupedLVectVect arg-2))))))))
(define UnitaryOp-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitaryOp-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitaryOp-u--applyUnitary_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitaryOp-applyUnitarySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitaryOp-u--applyCNOT_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitaryOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 2 (cons arg-1 (cons arg-2 '())) UnitaryLinear-CNOTGate eta-0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-0) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons clam-0 (cons e-2 (cons e-6 '()))))))))) ext-0)))
(define PreludeC-45Basics-irrelevantEq (vector 0 ))
(define DecidableC-45EqualityC-45Core-decEqCong (lambda (arg-6) (case (vector-ref arg-6 0) ((0) (vector 0 (vector 0 ))) (else (let ((e-3 (vector-ref arg-6 1))) (vector 1 (lambda (u--c) (e-3 PreludeC-45Basics-irrelevantEq))))))))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-124C-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-124C-41 (lambda (arg-0) (blodwen-error-quit "No clauses")))
(define DecidableC-45Equality-u--decEq_DecEq_Nat (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (vector 0 (vector 0 )))(else (vector 1 (lambda (eta-0) (PreludeC-45Uninhabited-absurd (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32ZC-41C-32C-40SC-32C-36nC-41C-41C-124C-41 eta-1)) eta-0))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (vector 1 (lambda (eta-0) (PreludeC-45Uninhabited-absurd (lambda (eta-1) (DataC-45Nat-u--uninhabited_Uninhabited_C-40C-124C-40C-40BuiltinC-46C-40C-61C-61C-61C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-44C-40C-40BuiltinC-46C-40C-126C-61C-126C-41C-32C-40SC-32C-36nC-41C-41C-32ZC-41C-124C-41 eta-1)) eta-0))))(else (let ((e-2 (- arg-1 1))) (DecidableC-45EqualityC-45Core-decEqCong (DecidableC-45Equality-u--decEq_DecEq_Nat e-0 e-2))))))))))
(define Qubit-findInLinQ (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (if (null? arg-2) (let ((e-4 (cdr arg-2))) e-4) '()))(else (let ((e-5 (- arg-0 1))) (if (null? arg-2) (let ((e-4 (cdr arg-2))) e-4) (let ((e-15 (car arg-2))) (let ((e-16 (cdr arg-2))) (let ((sc1 (DecidableC-45Equality-u--decEq_DecEq_Nat arg-1 e-15))) (case (vector-ref sc1 0) ((0) e-16) (else (cons e-15 (Qubit-findInLinQ e-5 arg-1 e-16)))))))))))))
(define UnitaryLinear-SAdj (lambda (arg-1 arg-2 arg-3) (vector 2 (/ (- 3.141592653589793) 2.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-SAdjGate (UnitaryLinear-SAdj 0 1 (vector 0 )))
(define UnitaryLinear-TAdj (lambda (arg-1 arg-2 arg-3) (vector 2 (/ (- 3.141592653589793) 4.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-TAdjGate (UnitaryLinear-TAdj 0 1 (vector 0 )))
(define UnitaryLinear-T (lambda (arg-1 arg-2 arg-3) (vector 2 (/ 3.141592653589793 4.0) arg-1 arg-2 arg-3)))
(define UnitaryLinear-TGate (UnitaryLinear-T 0 1 (vector 0 )))
(define UnitaryLinear-controlledH (lambda () (let ((u--h1 (UnitaryLinear-tensor 1 1 (vector 0 ) (UnitaryLinear-compose UnitaryLinear-SAdjGate (UnitaryLinear-compose UnitaryLinear-HGate (UnitaryLinear-compose UnitaryLinear-TGate csegen-138)))))) (let ((u--h2 (UnitaryLinear-tensor 1 1 (vector 0 ) (UnitaryLinear-compose UnitaryLinear-SAdjGate (UnitaryLinear-compose UnitaryLinear-HGate (UnitaryLinear-compose UnitaryLinear-TAdjGate csegen-138)))))) (UnitaryLinear-compose u--h1 (UnitaryLinear-compose UnitaryLinear-CNOTGate u--h2))))))
(define UnitaryLinear-controlledP (lambda (arg-0) (let ((u--p1 (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 2 (/ arg-0 2.0) 1 2 (vector 0 ))))) (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) (vector 2 (/ (- arg-0) 2.0) 1 2 u--p1)))))
(define Lemmas-ltzss (lambda (arg-0) (cond ((equal? arg-0 0) 1)(else (let ((e-0 (- arg-0 1))) (Lemmas-ltzss e-0))))))
(define Lemmas-lemmaControlledInj (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-1)) '()) (cons '() '())) (cons Lemmas-ltz1 (cons (+ arg-2 1) '())))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cons (cons csegen-153 (cons '() '())) (cons (Lemmas-ltzss e-0) (cons (+ arg-2 1) '()))))(else (let ((e-2 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) '()) (cons '() '())) (cons (Lemmas-ltzss e-0) (cons (+ arg-2 1) '())))))))))))
(define Lemmas-lt1ss (lambda (arg-0) (cond ((equal? arg-0 0) 2)(else (let ((e-0 (- arg-0 1))) (Lemmas-lt1ss e-0))))))
(define Lemmas-lemmaControlledInj2 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (- arg-1 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-1)) (cons (vector 0 (Lemmas-ltzs arg-2)) '())) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons Lemmas-ltz1 (cons (+ arg-3 1) (cons (+ arg-4 1) '()))))))))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (cons (cons (cons (vector 0 Lemmas-ltz1) csegen-153) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))(else (let ((e-3 (- arg-2 1))) (cons (cons (cons (vector 0 Lemmas-ltz1) (cons (vector 0 (Lemmas-ltzss e-3)) '())) (cons (cons (vector 0 (Lemmas-lt1ss e-3)) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '()))))))))(else (let ((e-2 (- arg-1 1))) (cond ((equal? arg-2 0) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) csegen-153) (cons (cons (vector 1 (Lemmas-lt1ss e-2)) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))(else (let ((e-4 (- arg-2 1))) (cons (cons (cons (vector 0 (Lemmas-ltzss e-2)) (cons (vector 0 (Lemmas-ltzss e-4)) '())) (cons (cons (Lemmas-eitherLTtoSucc arg-5) '()) (cons '() '()))) (cons (Lemmas-ltzss e-0) (cons (+ arg-3 1) (cons (+ arg-4 1) '())))))))))))))))
(define UnitaryLinear-toffoli (let ((u--g1 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (vector 1 2 3 (vector 0 ))))) (let ((u--g2 (vector 3 0 2 (Lemmas-lemma1LTESucc 2) 3 (vector 0 (Lemmas-lemma1LTESucc 1)) (UnitaryLinear-TAdj 2 3 u--g1)))) (let ((u--g3 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (UnitaryLinear-T 2 3 u--g2)))) (let ((u--g4 (vector 3 0 2 (Lemmas-lemma1LTESucc 2) 3 (vector 0 (Lemmas-lemma1LTESucc 1)) (UnitaryLinear-TAdj 2 3 u--g3)))) (let ((u--g5 (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (UnitaryLinear-T 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 1 2 3 (UnitaryLinear-T 2 3 u--g4)))))) (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (UnitaryLinear-T 0 (Lemmas-lemma1LTESucc 2) (UnitaryLinear-TAdj 1 (+ (Lemmas-lemma1LTESucc 1) 1) u--g5)))))))))
(define UnitaryLinear-controlled (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (vector 0 )) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((u--p (Lemmas-lemmaControlledInj arg-0 e-2 e-3))) (UnitaryLinear-apply 2 (+ arg-0 1) (UnitaryLinear-controlledH) (UnitaryLinear-controlled arg-0 e-4) (cons 0 (cons (+ e-2 1) '())) u--p)))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((u--p1 (Lemmas-lemmaControlledInj arg-0 e-7 e-8))) (UnitaryLinear-apply 2 (+ arg-0 1) (UnitaryLinear-controlledP e-6) (UnitaryLinear-controlled arg-0 e-9) (cons 0 (cons (+ e-7 1) '())) u--p1))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (let ((u--p (Lemmas-lemmaControlledInj2 arg-0 e-11 e-12 e-13 e-14 e-15))) (UnitaryLinear-apply 3 (+ arg-0 1) UnitaryLinear-toffoli (UnitaryLinear-controlled arg-0 e-16) (cons 0 (cons (+ e-11 1) (cons (+ e-12 1) '()))) u--p))))))))))))
(define UnitaryOp-case--caseC-32blockC-32inC-32applyControlSimulatedC-39-4354 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-8 arg-9 arg-10 arg-11) (let ((e-2 (car arg-11))) (let ((e-3 (cdr arg-11))) (let ((e-6 (vector-ref e-2 2))) (let ((e-7 (vector-ref e-2 3))) (let ((u--unew (UnitaryLinear-apply (+ arg-2 1) (+ arg-2 1) (UnitaryLinear-controlled arg-2 e-6) arg-4 (cons arg-9 e-7) (cons (Injection-findProofAllDiffOrFail (cons arg-9 e-7)) (Injection-findProofAllSmallerOrFail (+ arg-2 1) (cons arg-9 e-7)))))) (cons (vector (+ arg-2 1) arg-5 u--unew arg-3 arg-1) (cons arg-8 e-3)))))))))
(define UnitaryOp-case--applyControlSimulatedC-39-4317 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (let ((u--vn (Qubit-findInLinQ arg-2 e-2 arg-3))) (UnitaryOp-case--caseC-32blockC-32inC-32applyControlSimulatedC-39-4354 arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 e-2 e-3 u--vn (arg-6 (vector arg-2 (Matrix-neutralIdPow arg-2) (vector 0 ) u--vn arg-2))))))))
(define UnitaryOp-applyControlSimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-0 (vector-ref arg-4 0))) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (cond ((equal? e-0 0) (blodwen-error-quit "Nat case not covered"))(else (UnitaryOp-case--applyControlSimulatedC-39-4317 arg-1 e-4 arg-0 e-3 e-2 e-1 arg-3 (cons arg-2 arg-2)))))))))))
(define UnitaryOp-applyControlAbsSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitaryOp-applyControlSimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitaryOp-u--applyControlledAbs_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitaryOp-applyControlAbsSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define Matrix-matrixH (cons (cons csegen-167 (cons csegen-167 '())) (cons (cons csegen-167 (cons (cons (/ -1.0 (flsqrt 2.0)) 0.0) '())) '())))
(define Matrix-addCol (lambda (arg-2 arg-3) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((e-8 (car arg-3))) (let ((e-9 (cdr arg-3))) (cons (cons e-3 e-8) (Matrix-addCol e-4 e-9)))))))))
(define DataC-45Vect-replicate (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons arg-2 (DataC-45Vect-replicate e-0 arg-2)))))))
(define Matrix-transposeMatrix (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (DataC-45Vect-replicate arg-1 '()))(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (Matrix-addCol e-4 (Matrix-transposeMatrix e-0 arg-1 e-5)))))))))
(define Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 (lambda (arg-0 arg-1) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (cons (+ e-1 e-4) (+ e-2 e-5))))))))
(define Matrix-vectProduct (lambda (arg-1 arg-2) (if (null? arg-1) (cons 0.0 0.0) (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 (Complex-u--C-42_Num_C-40ComplexC-32DoubleC-41 e-3 e-8) (Matrix-vectProduct e-4 e-9)))))))))
(define Matrix-n--4800-2406-u--multVectMatrixC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-6 arg-7) (if (null? arg-7) '() (let ((e-3 (car arg-7))) (let ((e-4 (cdr arg-7))) (cons (Matrix-vectProduct arg-6 e-3) (Matrix-n--4800-2406-u--multVectMatrixC-39 arg-0 arg-1 arg-2 arg-3 arg-6 e-4)))))))
(define Matrix-multVectMatrix (lambda (arg-0 arg-1 arg-2 arg-3) (let ((u--mt (Matrix-transposeMatrix arg-0 arg-1 arg-3))) (Matrix-n--4800-2406-u--multVectMatrixC-39 arg-0 arg-1 arg-3 arg-2 arg-2 u--mt))))
(define Matrix-matrixMult (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (cons (Matrix-multVectMatrix arg-1 arg-2 e-4 arg-4) (Matrix-matrixMult e-0 arg-1 arg-2 e-5 arg-4)))))))))
(define Complex-cis (lambda (arg-0) (cons (flcos arg-0) (flsin arg-0))))
(define Matrix-matrixP (lambda (arg-0) (cons csegen-159 (cons (cons (cons 0.0 0.0) (cons (Complex-cis arg-0) '())) '()))))
(define DataC-45Nat-power (lambda (arg-0 arg-1) (cond ((equal? arg-1 0) 1)(else (let ((e-0 (- arg-1 1))) (* arg-0 (DataC-45Nat-power arg-0 e-0)))))))
(define Matrix-idRow (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cons (cons 1.0 0.0) (Matrix-idRow e-0 (+ e-0 1))))(else (let ((e-1 (- arg-1 1))) (cons (cons 0.0 0.0) (Matrix-idRow e-0 e-1))))))))))
(define Matrix-n--4551-2172-u--matrixIdC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons (Matrix-idRow arg-3 arg-2) (Matrix-n--4551-2172-u--matrixIdC-39 arg-0 e-0 (+ arg-2 1) arg-3)))))))
(define Matrix-matrixId (lambda (arg-0) (Matrix-n--4551-2172-u--matrixIdC-39 arg-0 arg-0 0 arg-0)))
(define Matrix-simpleTensor (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) csegen-85)(else (let ((e-0 (- arg-1 1))) (cond ((equal? arg-2 0) (Matrix-tensorProduct arg-0 (Matrix-simpleTensor arg-0 e-0 (+ e-0 1))))(else (let ((e-1 (- arg-2 1))) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-simpleTensor arg-0 e-0 e-1))))))))))
(define Matrix-addVector (lambda (arg-1 arg-2) (if (null? arg-1) '() (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (cons (Complex-u--C-43_Num_C-40ComplexC-32DoubleC-41 e-3 e-8) (Matrix-addVector e-4 e-9)))))))))
(define Matrix-addMatrix (lambda (arg-2 arg-3) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (let ((e-8 (car arg-3))) (let ((e-9 (cdr arg-3))) (cons (Matrix-addVector e-3 e-8) (Matrix-addMatrix e-4 e-9)))))))))
(define Matrix-matrixKet0Bra0 (cons csegen-159 (cons csegen-162 '())))
(define Matrix-matrixKet1Bra1 (cons csegen-162 (cons csegen-157 '())))
(define Matrix-matrixX (cons csegen-157 (cons csegen-159 '())))
(define Matrix-tensorCnotAux (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) csegen-85)(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-tensorCnotAux e-0 (+ e-0 1) (+ e-0 1))))(else (let ((e-2 (- arg-2 1))) (Matrix-tensorProduct Matrix-matrixKet1Bra1 (Matrix-tensorCnotAux e-0 (+ e-0 1) e-2))))))(else (let ((e-1 (- arg-1 1))) (cond ((equal? arg-2 0) (Matrix-tensorProduct Matrix-matrixX (Matrix-tensorCnotAux e-0 e-1 (+ e-0 1))))(else (let ((e-3 (- arg-2 1))) (Matrix-tensorProduct (Matrix-matrixId 2) (Matrix-tensorCnotAux e-0 e-1 e-3)))))))))))))
(define Matrix-tensorCNOT (lambda (arg-0 arg-1 arg-2) (Matrix-addMatrix (Matrix-simpleTensor Matrix-matrixKet0Bra0 arg-0 arg-1) (Matrix-tensorCnotAux arg-0 arg-1 arg-2))))
(define QuantumOp-applyCirc (lambda (arg-0 arg-1 arg-2 arg-3) (case (vector-ref arg-2 0) ((0) arg-3) ((1) (let ((e-2 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 2))) (let ((e-4 (vector-ref arg-2 3))) (let ((u--k (Injection-indexLT e-2 arg-1 e-3))) (let ((u--h (Matrix-simpleTensor Matrix-matrixH arg-0 u--k))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-4 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-6 (vector-ref sc1 3))) (let ((e-5 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--h e-1) (vector 0 ) e-6 e-5))))))))))) ((2) (let ((e-6 (vector-ref arg-2 1))) (let ((e-7 (vector-ref arg-2 2))) (let ((e-8 (vector-ref arg-2 3))) (let ((e-9 (vector-ref arg-2 4))) (let ((u--k (Injection-indexLT e-7 arg-1 e-8))) (let ((u--ph (Matrix-simpleTensor (Matrix-matrixP e-6) arg-0 u--k))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-9 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-3 (vector-ref sc1 3))) (let ((e-4 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--ph e-1) (vector 0 ) e-3 e-4)))))))))))) (else (let ((e-11 (vector-ref arg-2 1))) (let ((e-12 (vector-ref arg-2 2))) (let ((e-13 (vector-ref arg-2 3))) (let ((e-14 (vector-ref arg-2 4))) (let ((e-16 (vector-ref arg-2 6))) (let ((u--kc (Injection-indexLT e-11 arg-1 e-13))) (let ((u--kt (Injection-indexLT e-12 arg-1 e-14))) (let ((u--cn (Matrix-tensorCNOT arg-0 u--kc u--kt))) (let ((sc1 (QuantumOp-applyCirc arg-0 arg-1 e-16 arg-3))) (let ((e-1 (vector-ref sc1 1))) (let ((e-3 (vector-ref sc1 3))) (let ((e-4 (vector-ref sc1 4))) (vector arg-0 (Matrix-matrixMult (DataC-45Nat-power 2 arg-0) (DataC-45Nat-power 2 arg-0) 1 u--cn e-1) (vector 0 ) e-3 e-4)))))))))))))))))
(define QuantumOp-case--applyUnitaryC-39-3283 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-7) (let ((e-2 (car arg-7))) (let ((e-3 (cdr arg-7))) (let ((e-5 (vector-ref e-2 1))) (let ((e-6 (vector-ref e-2 2))) (let ((e-7 (vector-ref e-2 3))) (let ((e-8 (vector-ref e-2 4))) (let ((u--qs2 (QuantumOp-applyCirc arg-0 arg-3 e-6 (vector arg-0 e-5 e-6 e-7 e-8)))) (vector 1 (cons u--qs2 e-3)))))))))))
(define QuantumOp-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (let ((e-1 (vector-ref arg-3 1))) (let ((e-2 (vector-ref arg-3 2))) (let ((e-3 (vector-ref arg-3 3))) (let ((e-4 (vector-ref arg-3 4))) (QuantumOp-case--applyUnitaryC-39-3283 arg-0 arg-1 e-4 e-3 e-2 e-1 (arg-2 (vector arg-0 e-1 e-2 e-3 e-4)))))))))
(define QuantumOp-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 ext-0) (QuantumOp-applyUnitaryC-39 arg-0 arg-1 arg-2 ext-0)))
(define QuantumOp-u--applyUST_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-1 ext-0) (QuantumOp-applyUnitarySimulated arg-0 arg-1 ext-1 ext-0)))
(define QuantumOp-u--applyHQ_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp arg-1 1 (let ((e-4 (vector-ref arg-0 3))) ((e-4 arg-1) arg-2)) eta-0)) (lambda (u--q) (lambda (eta-0) (QStateT-pure u--q eta-0))) ext-0)))
(define UnitaryOp-u--applyH_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitaryOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 1 (cons arg-1 '()) UnitaryLinear-HGate eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitaryLinear-PGate (lambda (arg-0) (vector 2 arg-0 0 1 (vector 0 ))))
(define UnitaryOp-u--applyP_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitaryOp-u--applyUnitary_UnitaryOp_SimulatedOp arg-0 1 (cons arg-2 '()) (UnitaryLinear-PGate arg-1) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitaryOp-applyUnitaryAbsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (let ((e-1 (vector-ref arg-3 1))) (let ((e-2 (vector-ref arg-3 2))) (let ((e-3 (vector-ref arg-3 3))) (let ((e-4 (vector-ref arg-3 4))) (let ((sc0 (arg-2 (vector arg-0 e-1 e-2 e-3 e-4)))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-9 (vector-ref e-6 2))) (let ((e-7 (vector-ref e-6 3))) (let ((u--unew (UnitaryLinear-compose e-9 e-2))) (cons (vector arg-0 e-1 u--unew e-7 e-4) e-5)))))))))))))
(define UnitaryOp-applyUnitaryAbsSimulated (lambda (arg-0 arg-1 arg-2 ext-0) (UnitaryOp-applyUnitaryAbsC-39 arg-0 arg-1 arg-2 ext-0)))
(define UnitaryOp-u--applyUnitaryAbs_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-1 ext-0) (UnitaryOp-applyUnitaryAbsSimulated arg-0 arg-1 ext-1 ext-0)))
(define QuantumOp-case--applyUDirectlySimulatedC-39-3370 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-7 arg-8) (let ((e-2 (car arg-8))) (let ((e-3 (cdr arg-8))) (let ((u--unew (UnitaryLinear-apply arg-1 arg-0 arg-7 (vector 0 ) e-3 (cons (Injection-findProofAllDiffOrFail e-3) (Injection-findProofAllSmallerOrFail arg-0 e-3))))) (let ((u--qs2 (QuantumOp-applyCirc arg-0 arg-3 u--unew (vector arg-0 arg-5 arg-4 arg-3 arg-2)))) (vector 1 (cons u--qs2 e-2))))))))
(define QuantumOp-applyUDirectlySimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (QuantumOp-case--applyUDirectlySimulatedC-39-3370 arg-0 arg-1 e-4 e-3 e-2 e-1 arg-2 (Qubit-distributeDupedLVectVect arg-3))))))))
(define QuantumOp-applyUDirectlySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (QuantumOp-applyUDirectlySimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define QuantumOp-u--applyUnitaryDirectly_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (QuantumOp-applyUDirectlySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitaryOp-case--applyUnitaryOwnC-39-3919 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9 arg-11) (let ((e-2 (car arg-11))) (let ((e-3 (cdr arg-11))) (let ((u--unew (UnitaryLinear-apply arg-1 arg-6 arg-3 arg-8 e-3 (cons (Injection-findProofAllDiffOrFail e-3) (Injection-findProofAllSmallerOrFail arg-6 e-3))))) (cons (vector arg-6 arg-9 u--unew arg-7 arg-5) e-2))))))
(define UnitaryOp-applyUnitaryOwnC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((e-1 (vector-ref arg-2 1))) (let ((e-2 (vector-ref arg-2 2))) (let ((e-3 (vector-ref arg-2 3))) (let ((e-4 (vector-ref arg-2 4))) (let ((e-6 (vector-ref arg-4 1))) (let ((e-7 (vector-ref arg-4 2))) (let ((e-8 (vector-ref arg-4 3))) (let ((e-9 (vector-ref arg-4 4))) (UnitaryOp-case--applyUnitaryOwnC-39-3919 e-4 arg-1 e-3 e-2 e-1 e-9 arg-0 e-8 e-7 e-6 (Qubit-distributeDupedLVectVect arg-3))))))))))))
(define UnitaryOp-applyUnitaryOwnSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitaryOp-applyUnitaryOwnC-39 arg-0 arg-1 arg-3 arg-2 ext-0)))
(define UnitaryOp-u--applyUnitaryOwn_UnitaryOp_SimulatedOp (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitaryOp-applyUnitaryOwnSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitaryOp-exportSelfC-39 (lambda (arg-1 arg-2 arg-3) (let ((sc0 (arg-3 arg-2))) (let ((e-2 (car sc0))) e-2))))
(define UnitaryOp-u--exportSelf_UnitaryOp_SimulatedOp (lambda (arg-1 ext-0 ext-1) (UnitaryOp-exportSelfC-39 arg-1 ext-0 ext-1)))
(define LinearTypes-consLin (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) (cons 0 '()) (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (cons 0 (cons e-3 e-4)))))) (else (if (null? arg-2) (cons 1 '()) (let ((e-8 (car arg-2))) (let ((e-9 (cdr arg-2))) (cons 1 (cons e-8 e-9)))))))))
(define Qubit-listIndexC-39 (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) 0)(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (let ((sc1 (or (and (= e-4 arg-2) 1) 0))) (cond ((equal? sc1 1) 0) (else (+ (Qubit-listIndexC-39 e-0 e-5 arg-2) 1)))))))))))
(define UnitaryOp-case--listIndex-3356 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-6) (let ((e-2 (car arg-6))) (cons (cons (vector arg-0 arg-4 arg-3 arg-2 arg-1) e-2) (Qubit-listIndexC-39 arg-0 arg-2 e-2)))))
(define UnitaryOp-listIndex (lambda (arg-1 arg-2) (let ((e-0 (vector-ref arg-1 0))) (let ((e-1 (vector-ref arg-1 1))) (let ((e-2 (vector-ref arg-1 2))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (UnitaryOp-case--listIndex-3356 e-0 e-4 e-3 e-2 e-1 (cons arg-2 arg-2)))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Matrix-inv (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Double arg-0 0.0))) (cond ((equal? sc0 1) 0.0) (else (/ 1.0 arg-0))))))
(define Complex-magnitude (lambda (arg-0) (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (flsqrt (+ (* e-1 e-1) (* e-2 e-2)))))))
(define Matrix-normState2 (lambda (arg-1) (if (null? arg-1) 0.0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (let ((e-7 (car e-3))) (let ((e-8 (cdr e-3))) (let ((u--m (Complex-magnitude e-7))) (+ (* u--m u--m) (Matrix-normState2 e-4))))))))))
(define DataC-45Vect-with--splitAt-5632 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (cons (cons arg-5 e-2) e-3)))))
(define DataC-45Vect-splitAt (lambda (arg-2 arg-3) (cond ((equal? arg-2 0) (cons '() arg-3))(else (let ((e-0 (- arg-2 1))) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (DataC-45Vect-with--splitAt-5632 'erased 'erased e-0 e-4 (DataC-45Vect-splitAt e-0 e-4) e-3))))))))
(define Matrix-projectState (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) (let ((sc1 (DataC-45Vect-splitAt (DataC-45Nat-power 2 arg-0) arg-1))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cond ((equal? arg-3 1) e-3) (else e-2))))))(else (cond ((equal? arg-0 0) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else csegen-85)))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-2 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-2 (- arg-2 1))) (let ((sc0 (DataC-45Vect-splitAt (DataC-45Nat-power 2 (+ e-0 1)) arg-1))) (let ((e-4 (car sc0))) (let ((e-3 (cdr sc0))) (let ((u--v1C-39 (Matrix-projectState e-0 e-4 e-2 arg-3))) (let ((u--v2C-39 (Matrix-projectState e-0 e-3 e-2 arg-3))) (DataC-45Vect-C-43C-43 u--v1C-39 u--v2C-39))))))))))))))))
(define UnitaryOp-removeElem (lambda (arg-0 arg-1 arg-2) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? arg-2 0) e-3)(else (let ((e-4 (- arg-2 1))) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons e-2 (UnitaryOp-removeElem e-0 e-3 e-4))))))))))))
(define PreludeC-45EqOrd-u--C-60_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Builtin-snd (lambda (arg-2) (let ((e-3 (cdr arg-2))) e-3)))
(define ControlC-45LinearC-45LIO-u--liftIO1_HasLinearIO_C-40LC-32C-36ioC-41 (lambda (arg-2 arg-3) (vector 3 (let ((sc0 (Builtin-snd arg-2))) (let ((e-2 (cdr sc0))) ((e-2 'erased) arg-3))))))
(define SystemC-45Random-randomDouble (lambda (ext-0) (SystemC-45Random-prim__randomDouble ext-0)))
(define SystemC-45Random-u--randomIO_Random_Double (lambda (arg-1) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45Random-randomDouble eta-0))))))
(define QuantumOp-measureC-39 (lambda (arg-0 arg-1 arg-2) (let ((e-0 (vector-ref arg-2 0))) (let ((e-1 (vector-ref arg-2 1))) (let ((e-3 (vector-ref arg-2 3))) (let ((e-4 (vector-ref arg-2 4))) (cond ((equal? e-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((u--projector0 (Matrix-simpleTensor Matrix-matrixKet0Bra0 (+ arg-0 1) arg-1))) (let ((u--projection0 (Matrix-matrixMult (DataC-45Nat-power 2 (+ arg-0 1)) (DataC-45Nat-power 2 (+ arg-0 1)) 1 u--projector0 e-1))) (let ((u--norm20 (Matrix-normState2 u--projection0))) (let ((u--projector1 (Matrix-simpleTensor Matrix-matrixKet1Bra1 (+ arg-0 1) arg-1))) (let ((u--projection1 (Matrix-matrixMult (DataC-45Nat-power 2 (+ arg-0 1)) (DataC-45Nat-power 2 (+ arg-0 1)) 1 u--projector1 e-1))) (let ((u--norm21 (Matrix-normState2 u--projection1))) (let ((u--newQubits (UnitaryOp-removeElem arg-0 e-3 arg-1))) (vector 4 2 (ControlC-45LinearC-45LIO-u--liftIO1_HasLinearIO_C-40LC-32C-36ioC-41 (cons csegen-83 (cons csegen-93 (lambda (u--a) (lambda (arg-13157) arg-13157)))) (SystemC-45Random-u--randomIO_Random_Double csegen-96)) (lambda (u--randnb) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Double u--randnb u--norm20))) (cond ((equal? sc0 1) (let ((u--proj (Matrix-multScalarMatrix (cons (Matrix-inv (flsqrt u--norm20)) 0.0) u--projection0))) (vector 1 (cons (vector arg-0 (Matrix-projectState arg-0 u--proj arg-1 0) (vector 0 ) u--newQubits e-4) 0)))) (else (let ((u--proj (Matrix-multScalarMatrix (cons (Matrix-inv (flsqrt u--norm21)) 0.0) u--projection1))) (vector 1 (cons (vector arg-0 (Matrix-projectState arg-0 u--proj arg-1 1) (vector 0 ) u--newQubits e-4) 1)))))))))))))))))))))))
(define QuantumOp-measureQubitsC-39C-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (vector 1 (cons arg-3 '())))(else (let ((e-0 (- arg-1 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc1 (UnitaryOp-listIndex arg-3 e-4))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (let ((e-6 (car e-2))) (vector 4 1 (QuantumOp-measureC-39 (+ e-0 arg-0) e-3 e-6) (lambda (_-0) (let ((e-9 (car _-0))) (let ((e-8 (cdr _-0))) (vector 4 1 (QuantumOp-measureQubitsC-39C-39 arg-0 e-0 e-5 e-9) (lambda (_-1) (let ((e-11 (car _-1))) (let ((e-10 (cdr _-1))) (cond ((equal? e-0 0) (vector 1 (cons e-11 (cons e-8 '()))))(else (let ((e-13 (car e-10))) (let ((e-12 (cdr e-10))) (vector 1 (cons e-11 (cons e-8 (cons e-13 e-12)))))))))))))))))))))))))))
(define Qubit-smallestMissingC-39 (lambda (arg-1) (if (null? arg-1) 0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (cond ((equal? e-3 0) (if (null? e-4) 1 (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (let ((sc4 (DecidableC-45Equality-u--decEq_DecEq_Nat (+ e-3 1) e-7))) (case (vector-ref sc4 0) ((0) (Qubit-smallestMissingC-39 (cons e-7 e-8))) (else (+ e-3 1))))))))(else (let ((e-9 (- e-3 1))) (if (null? e-4) (+ (+ e-9 1) 1) (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (let ((sc3 (DecidableC-45Equality-u--decEq_DecEq_Nat (+ e-3 1) e-7))) (case (vector-ref sc3 0) ((0) (Qubit-smallestMissingC-39 (cons e-7 e-8))) (else (+ e-3 1)))))))))))))))
(define Qubit-smallestMissing (lambda (arg-1) (if (null? arg-1) 0 (let ((e-3 (car arg-1))) (let ((e-4 (cdr arg-1))) (cond ((equal? e-3 0) (if (null? e-4) 1 (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (cond ((equal? e-3 0) (let ((sc5 (DecidableC-45Equality-u--decEq_DecEq_Nat 1 e-7))) (case (vector-ref sc5 0) ((0) (Qubit-smallestMissingC-39 (cons e-7 e-8))) (else 1))))(else 0))))))(else (let ((e-9 (- e-3 1))) (if (null? e-4) (+ (+ e-9 1) 1) (let ((e-7 (car e-4))) (let ((e-8 (cdr e-4))) (cond ((equal? e-3 0) (let ((sc4 (DecidableC-45Equality-u--decEq_DecEq_Nat 1 e-7))) (case (vector-ref sc4 0) ((0) (Qubit-smallestMissingC-39 (cons e-7 e-8))) (else 1))))(else 0)))))))))))))
(define DataC-45NatC-45Views-with--half-2505 (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (let ((e-0 (vector-ref arg-1 1))) (vector 0 e-0)))(else (case (vector-ref arg-1 0) ((0) (let ((e-2 (vector-ref arg-1 1))) (vector 1 (+ e-2 1))))(else (let ((e-0 (vector-ref arg-1 1))) (vector 0 e-0))))))))
(define DataC-45NatC-45Views-half (lambda (arg-0) (cond ((equal? arg-0 0) (vector 1 0))(else (let ((e-0 (- arg-0 1))) (DataC-45NatC-45Views-with--half-2505 e-0 (DataC-45NatC-45Views-half e-0)))))))
(define DataC-45Vect-mergeBy (lambda (arg-3 arg-4 arg-5) (if (null? arg-4) arg-5 (if (null? arg-5) arg-4 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (let ((e-6 (car arg-5))) (let ((e-7 (cdr arg-5))) (let ((sc4 ((arg-3 e-2) e-6))) (cond ((equal? sc4 0) (cons e-2 (DataC-45Vect-mergeBy arg-3 e-3 (cons e-6 e-7))))(else (cons e-6 (DataC-45Vect-mergeBy arg-3 (cons e-2 e-3) e-7)))))))))))))
(define DataC-45VectC-45Sort-sortByMerge (lambda (arg-1 arg-2 arg-3 arg-4) (let ((sc0 (DataC-45Vect-splitAt arg-1 arg-4))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (DataC-45Vect-mergeBy arg-3 (DataC-45VectC-45Sort-sortBySplit arg-1 arg-3 e-2) (DataC-45VectC-45Sort-sortBySplit arg-2 arg-3 e-3)))))))
(define DataC-45VectC-45Sort-with--sortBySplit-2662 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (case (vector-ref arg-1 0) ((1) (let ((e-2 (vector-ref arg-1 1))) (DataC-45VectC-45Sort-sortByMerge e-2 e-2 arg-4 arg-3)))(else (cond ((equal? arg-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-1 (vector-ref arg-1 1))) (DataC-45VectC-45Sort-sortByMerge (+ e-1 1) e-1 arg-4 arg-3))))))))
(define DataC-45VectC-45Sort-sortBySplit (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (if (null? arg-3) '() (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2)))(else (let ((e-0 (- arg-1 1))) (cond ((equal? e-0 0) (if (null? arg-3) (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (if (null? e-5) (cons e-4 '()) (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2))))))(else (DataC-45VectC-45Sort-with--sortBySplit-2662 arg-1 (DataC-45NatC-45Views-half arg-1) 'erased arg-3 arg-2))))))))
(define DataC-45VectC-45Sort-sortBy (lambda (arg-1 arg-2 arg-3) (DataC-45VectC-45Sort-sortBySplit arg-1 arg-2 arg-3)))
(define DataC-45VectC-45Sort-sort (lambda (arg-1 arg-2 ext-0) (DataC-45VectC-45Sort-sortBy arg-2 (lambda (eta-0) (lambda (eta-1) (let ((e-2 (vector-ref arg-1 1))) ((e-2 eta-0) eta-1)))) ext-0)))
(define PreludeC-45Types-u--C-47C-61_Eq_Nat (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Types-u--C-60C-61_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define PreludeC-45Types-u--C-60_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define PreludeC-45Types-u--C-62C-61_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define PreludeC-45Types-u--C-62_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define PreludeC-45Types-u--max_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-62_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define PreludeC-45Types-u--min_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-60_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define Qubit-reCalculateCounter (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) 0)(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (Qubit-smallestMissing (DataC-45VectC-45Sort-sort (vector (cons (lambda (arg-676) (lambda (arg-679) (or (and (= arg-676 arg-679) 1) 0))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45Types-u--C-47C-61_Eq_Nat arg-686 arg-689)))) (lambda (arg-1566) (lambda (arg-1569) (PreludeC-45EqOrd-u--compare_Ord_Integer arg-1566 arg-1569))) (lambda (arg-1576) (lambda (arg-1579) (PreludeC-45Types-u--C-60_Ord_Nat arg-1576 arg-1579))) (lambda (arg-1586) (lambda (arg-1589) (PreludeC-45Types-u--C-62_Ord_Nat arg-1586 arg-1589))) (lambda (arg-1596) (lambda (arg-1599) (PreludeC-45Types-u--C-60C-61_Ord_Nat arg-1596 arg-1599))) (lambda (arg-1606) (lambda (arg-1609) (PreludeC-45Types-u--C-62C-61_Ord_Nat arg-1606 arg-1609))) (lambda (arg-1616) (lambda (arg-1619) (PreludeC-45Types-u--max_Ord_Nat arg-1616 arg-1619))) (lambda (arg-1626) (lambda (arg-1629) (PreludeC-45Types-u--min_Ord_Nat arg-1626 arg-1629)))) (+ e-0 1) (cons e-4 e-5))))))))))
(define QuantumOp-measureQubitsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (vector 1 (cons arg-3 '())))(else (let ((e-0 (- arg-1 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc1 (UnitaryOp-listIndex arg-3 e-4))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (let ((e-6 (car e-2))) (vector 4 1 (QuantumOp-measureC-39 (+ e-0 arg-0) e-3 e-6) (lambda (_-0) (let ((e-9 (car _-0))) (let ((e-8 (cdr _-0))) (vector 4 1 (QuantumOp-measureQubitsC-39C-39 arg-0 e-0 e-5 e-9) (lambda (_-1) (let ((e-11 (car _-1))) (let ((e-10 (cdr _-1))) (let ((e-15 (vector-ref e-11 1))) (let ((e-14 (vector-ref e-11 2))) (let ((e-13 (vector-ref e-11 3))) (cond ((equal? e-0 0) (vector 1 (cons (vector arg-0 e-15 e-14 e-13 (Qubit-reCalculateCounter arg-0 e-13)) (cons e-8 '()))))(else (let ((e-18 (car e-10))) (let ((e-17 (cdr e-10))) (vector 1 (cons (vector arg-0 e-15 e-14 e-13 (Qubit-reCalculateCounter arg-0 e-13)) (cons e-8 (cons e-18 e-17))))))))))))))))))))))))))))))
(define QuantumOp-measureSimulated (lambda (arg-0 arg-1 arg-2 ext-0) (QuantumOp-measureQubitsC-39 arg-0 arg-1 arg-2 ext-0)))
(define QuantumOp-u--measure_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-1 ext-0) (QuantumOp-measureSimulated arg-0 arg-1 ext-1 ext-0)))
(define QuantumOp-u--measureQubit_QuantumOp_SimulatedOp (lambda (arg-0 arg-1 ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--measure_QuantumOp_SimulatedOp arg-0 1 (cons arg-1 '()) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (QStateT-pure e-2 clam-0))))) ext-0)))
(define QuantumOp-u--measureAll_QuantumOp_SimulatedOp (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (lambda (clam-0) (QStateT-pure '() clam-0)))(else (let ((e-0 (- arg-0 1))) (lambda (clam-1) (let ((e-4 (car arg-1))) (let ((e-5 (cdr arg-1))) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--measureQubit_QuantumOp_SimulatedOp e-0 e-4 eta-0)) (lambda (u--b) (lambda (eta-0) (QStateT-C-62C-62C-61 (QuantumOp-u--measureAll_QuantumOp_SimulatedOp e-0 e-5) (lambda (u--bs) (lambda (eta-1) (QStateT-pure (LinearTypes-consLin u--b u--bs) eta-1))) eta-0))) clam-1)))))))))
(define Matrix-ket0 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons csegen-159 (Matrix-ket0 e-0)))))))
(define Qubit-newQubitsPointers (lambda (arg-0 arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (cons '() (cons '() arg-2)))(else (let ((e-0 (- arg-1 1))) (let ((u--newcounter (Qubit-reCalculateCounter (+ arg-0 1) (cons arg-2 arg-3)))) (let ((sc0 (Qubit-newQubitsPointers (+ arg-0 1) e-0 u--newcounter (cons arg-2 arg-3)))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons (cons arg-2 e-2) (cons (cons arg-2 e-6) e-7)))))))))))))
(define Matrix-tensorProductVect (lambda (arg-2 arg-3) (Matrix-tensorProduct arg-2 arg-3)))
(define QuantumOp-n--8012-4320-u--newQubitsC-39 (lambda (arg-1 arg-3 arg-4) (let ((e-0 (vector-ref arg-4 0))) (let ((e-1 (vector-ref arg-4 1))) (let ((e-2 (vector-ref arg-4 2))) (let ((e-3 (vector-ref arg-4 3))) (let ((e-4 (vector-ref arg-4 4))) (let ((u--sC-39 (Matrix-toTensorBasis (Matrix-ket0 arg-3)))) (let ((sc0 (Qubit-newQubitsPointers e-0 arg-3 e-4 e-3))) (let ((e-6 (car sc0))) (let ((e-5 (cdr sc0))) (let ((e-8 (car e-5))) (let ((e-7 (cdr e-5))) (vector 1 (cons (vector (+ e-0 arg-3) (Matrix-tensorProductVect e-1 u--sC-39) (UnitaryLinear-tensor e-0 arg-3 e-2 (vector 0 )) (DataC-45Vect-C-43C-43 e-3 e-8) e-7) e-6)))))))))))))))
(define QuantumOp-newQubitsSimulated (lambda (arg-1 ext-0) (QuantumOp-n--8012-4320-u--newQubitsC-39 arg-1 arg-1 ext-0)))
(define QuantumOp-u--newQubits_QuantumOp_SimulatedOp (lambda (ext-1 ext-0) (QuantumOp-newQubitsSimulated ext-1 ext-0)))
(define QuantumOp-u--newQubit_QuantumOp_SimulatedOp (lambda (ext-0) (QStateT-C-62C-62C-61 (lambda (eta-0) (QuantumOp-u--newQubits_QuantumOp_SimulatedOp 1 eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (QStateT-pure e-2 clam-0))))) ext-0)))
(define ControlC-45LinearC-45LIO-runK (lambda (arg-3 arg-4 arg-5 arg-6) (cond ((equal? arg-3 0) (case (vector-ref arg-5 0) ((0) (arg-6 'erased)) ((3) (let ((e-13 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-13) (lambda (u--xC-39) (arg-6 'erased)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))) ((equal? arg-3 1) (case (vector-ref arg-5 0) ((1) (let ((e-16 (vector-ref arg-5 1))) (arg-6 e-16))) ((3) (let ((e-20 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-20) (lambda (u--xC-39) (arg-6 u--xC-39)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))) ((equal? arg-3 2) (case (vector-ref arg-5 0) ((2) (let ((e-23 (vector-ref arg-5 1))) (arg-6 e-23))) ((3) (let ((e-27 (vector-ref arg-5 1))) ((((arg-4 'erased) 'erased) e-27) (lambda (u--xC-39) (arg-6 u--xC-39)))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))))))))))(else (let ((e-4 (vector-ref arg-5 1))) (let ((e-5 (vector-ref arg-5 2))) (let ((e-6 (vector-ref arg-5 3))) (cond ((equal? e-4 0) (ControlC-45LinearC-45LIO-runK 0 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 'erased) arg-6)))) ((equal? e-4 1) (ControlC-45LinearC-45LIO-runK 1 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6)))) (else (ControlC-45LinearC-45LIO-runK 2 arg-4 e-5 (lambda (u--x) (ControlC-45LinearC-45LIO-runK arg-3 arg-4 (e-6 u--x) arg-6))))))))))))
(define ControlC-45LinearC-45LIO-run (lambda (arg-2 arg-3 arg-4) (ControlC-45LinearC-45LIO-runK 2 arg-3 arg-4 (lambda (eta-0) (let ((e-2 (vector-ref arg-2 1))) ((e-2 'erased) eta-0))))))
(define ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 (lambda (arg-2 ext-0) (vector 2 ext-0)))
(define QuantumOp-runSimulated (lambda (arg-0 arg-1) (ControlC-45LinearC-45LIO-run csegen-34 csegen-83 (vector 4 1 (arg-1 (vector 0 csegen-85 (vector 0 ) '() 0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (let ((e-4 (vector-ref e-2 0))) (cond ((equal? e-4 0) (cond ((equal? arg-0 0) (ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 csegen-34 '()))(else (let ((e-10 (car e-3))) (let ((e-9 (cdr e-3))) (ControlC-45LinearC-45LIO-u--pure_Applicative_C-40LC-32C-36ioC-41 csegen-34 (cons e-10 e-9)))))))(else (blodwen-error-quit "Nat case not covered")))))))))))
(define QuantumOp-u--runQ_QuantumOp_SimulatedOp (lambda (arg-0 ext-0) (QuantumOp-runSimulated arg-0 ext-0)))
(define UnitaryOp-u--run_UnitaryOp_SimulatedOp (lambda (arg-1 ext-0 ext-1) (ext-1 ext-0)))
(define PreludeC-45Types-u--traverse_Traversable_List (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) '())) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((e-4 (vector-ref arg-3 2))) ((((e-4 'erased) 'erased) (let ((e-6 (vector-ref arg-3 2))) ((((e-6 'erased) 'erased) (let ((e-10 (vector-ref arg-3 1))) ((e-10 'erased) csegen-113))) (arg-4 e-2)))) (PreludeC-45Types-u--traverse_Traversable_List arg-3 arg-4 e-3))))))))
(define Main-testCoins (lambda () (let ((u--f (lambda (eta-0) (CoinToss-coin (vector (lambda (u--n) (lambda (u--i) (lambda (arg-1261) (lambda (arg-1264) (lambda (eta-1) (UnitaryOp-u--applyUnitary_UnitaryOp_SimulatedOp u--n u--i arg-1261 arg-1264 eta-1)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1277) (lambda (u--ownUnitary) (lambda (eta-1) (UnitaryOp-u--applyUnitaryOwn_UnitaryOp_SimulatedOp u--n u--i arg-1277 u--ownUnitary eta-1)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1292) (lambda (eta-1) (UnitaryOp-u--applyUnitaryAbs_UnitaryOp_SimulatedOp u--n u--i arg-1292 eta-1))))) (lambda (u--n) (lambda (arg-1302) (lambda (eta-1) (UnitaryOp-u--applyH_UnitaryOp_SimulatedOp u--n arg-1302 eta-1)))) (lambda (u--n) (lambda (arg-1314) (lambda (arg-1317) (lambda (eta-1) (UnitaryOp-u--applyP_UnitaryOp_SimulatedOp u--n arg-1314 arg-1317 eta-1))))) (lambda (u--n) (lambda (arg-1330) (lambda (arg-1333) (lambda (eta-1) (UnitaryOp-u--applyCNOT_UnitaryOp_SimulatedOp u--n arg-1330 arg-1333 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1348) (lambda (arg-1351) (lambda (eta-1) (UnitaryOp-u--applyControlledAbs_UnitaryOp_SimulatedOp u--n u--i arg-1348 arg-1351 eta-1)))))) (lambda (u--i) (lambda (u--n) (lambda (arg-1363) (lambda (eta-1) (UnitaryOp-u--adjointUST_UnitaryOp_SimulatedOp arg-1363 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1371) (lambda (arg-1374) (UnitaryOp-u--run_UnitaryOp_SimulatedOp u--i arg-1371 arg-1374))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1384) (lambda (arg-1387) (UnitaryOp-u--exportSelf_UnitaryOp_SimulatedOp u--i arg-1384 arg-1387)))))) (vector (lambda (u--n) (lambda (u--p) (lambda (eta-1) (QuantumOp-u--newQubits_QuantumOp_SimulatedOp u--p eta-1)))) (lambda (u--n) (lambda (eta-1) (QuantumOp-u--newQubit_QuantumOp_SimulatedOp eta-1))) (lambda (u--n) (lambda (u--i) (lambda (arg-2155) (lambda (eta-1) (QuantumOp-u--applyUST_QuantumOp_SimulatedOp u--n u--i arg-2155 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-2167) (lambda (arg-2170) (lambda (eta-1) (QuantumOp-u--applyUnitaryDirectly_QuantumOp_SimulatedOp u--n u--i arg-2167 arg-2170 eta-1)))))) (lambda (i_con-0) (lambda (u--n) (lambda (arg-2184) (lambda (eta-1) (QuantumOp-u--applyHQ_QuantumOp_SimulatedOp i_con-0 u--n arg-2184 eta-1))))) (lambda (u--n) (lambda (u--i) (lambda (arg-2199) (lambda (eta-1) (QuantumOp-u--measure_QuantumOp_SimulatedOp u--n u--i arg-2199 eta-1))))) (lambda (u--n) (lambda (arg-2211) (lambda (eta-1) (QuantumOp-u--measureQubit_QuantumOp_SimulatedOp u--n arg-2211 eta-1)))) (lambda (u--n) (lambda (arg-2221) (QuantumOp-u--measureAll_QuantumOp_SimulatedOp u--n arg-2221))) (lambda (u--n) (lambda (arg-2233) (QuantumOp-u--runQ_QuantumOp_SimulatedOp u--n arg-2233)))) eta-0)))) (lambda (world-0) (let ((act-1 ((PreludeC-45Interfaces-sequence csegen-34 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8885) (PreludeC-45TypesC-45List-mapAppend '() u--func arg-8885))))) csegen-52 (lambda (u--b) (lambda (u--a) (lambda (f-0) (lambda (i_con-0) (lambda (arg-14093) (lambda (arg-14100) (PreludeC-45Types-u--traverse_Traversable_List i_con-0 arg-14093 arg-14100)))))))) (DataC-45List-replicateTR '() 1000 u--f)) world-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "Number of heads: " (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (PreludeC-45TypesC-45List-filterAppend '() (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Bool arg-0 1)) act-1)))) "\xa;") world-0))))))
(define Examples-toBellBasis (vector 3 0 1 (Lemmas-lemma1LTESucc 1) 2 (vector 0 1) csegen-178))
(define Examples-adjoint_example1 (UnitaryLinear-adjoint Examples-toBellBasis))
(define Examples-adjoint_example2 (UnitaryLinear-adjoint UnitaryLinear-toffoli))
(define Examples-drawAdjointExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using adjoint\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : adjoint toBellBasis\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 2 Examples-adjoint_example1) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : adjoint toffoli\xa;" ext-0))) ((UnitaryLinear-draw 3 Examples-adjoint_example2) ext-0)))))))
(define Examples-compose_example1 (UnitaryLinear-compose UnitaryLinear-TGate UnitaryLinear-HGate))
(define Examples-compose_example2 (UnitaryLinear-compose (vector 1 1 2 (vector 0 )) (UnitaryLinear-compose (vector 2 3.141592653589793 0 (Lemmas-lemma1LTESucc 1) (vector 0 )) Examples-toBellBasis)))
(define Examples-drawComposeExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using composition\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : TGate . HGate\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 1 Examples-compose_example1) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : (H 1 IdGate) . (P pi 0 IdGate) . toBellBasis\xa;" ext-0))) ((UnitaryLinear-draw 2 Examples-compose_example2) ext-0)))))))
(define UnitaryLinear-addDepth (lambda (arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-2 0) (let ((e-4 (cdr arg-3))) (cons arg-1 e-4)))(else (let ((e-0 (- arg-2 1))) (let ((e-7 (car arg-3))) (let ((e-8 (cdr arg-3))) (cons e-7 (UnitaryLinear-addDepth arg-1 e-0 e-8 (DataC-45Nat-fromLteSucc arg-4))))))))))
(define UnitaryLinear-findValue (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-1 0) (let ((e-3 (car arg-2))) e-3))(else (let ((e-0 (- arg-1 1))) (let ((e-8 (cdr arg-2))) (UnitaryLinear-findValue e-0 e-8 (DataC-45Nat-fromLteSucc arg-3))))))))
(define UnitaryLinear-depthC-39 (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (DataC-45Vect-replicate arg-0 0)) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-4))) (let ((u--k (UnitaryLinear-findValue e-2 u--v e-3))) (UnitaryLinear-addDepth (+ u--k 1) e-2 u--v e-3))))))) ((2) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-9))) (let ((u--k (UnitaryLinear-findValue e-7 u--v e-8))) (UnitaryLinear-addDepth (+ u--k 1) e-7 u--v e-8))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-16 (vector-ref arg-1 6))) (let ((u--v (UnitaryLinear-depthC-39 arg-0 e-16))) (let ((u--k (UnitaryLinear-findValue e-11 u--v e-13))) (let ((u--m (UnitaryLinear-findValue e-12 u--v e-14))) (let ((sc1 (PreludeC-45Types-u--C-60_Ord_Nat u--k u--m))) (cond ((equal? sc1 1) (let ((u--w (UnitaryLinear-addDepth (+ u--m 1) e-11 u--v e-13))) (UnitaryLinear-addDepth (+ u--m 1) e-12 u--w e-14))) (else (let ((u--w (UnitaryLinear-addDepth (+ u--k 1) e-11 u--v e-13))) (UnitaryLinear-addDepth (+ u--k 1) e-12 u--w e-14)))))))))))))))))
(define DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) arg-4 (let ((e-3 (car arg-5))) (let ((e-4 (cdr arg-5))) (DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 arg-3 ((arg-3 arg-4) e-3) e-4))))))
(define UnitaryLinear-depth (lambda (arg-0 arg-1) (let ((u--v (UnitaryLinear-depthC-39 arg-0 arg-1))) (DataC-45Vect-u--foldl_Foldable_C-40VectC-32C-36nC-41 (lambda (eta-0) (lambda (eta-1) (PreludeC-45Types-u--max_Ord_Nat eta-0 eta-1))) 0 u--v))))
(define Examples-depthExample2 (vector 1 2 3 (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 1 0 (Lemmas-lemma1LTESucc 2) csegen-212))))
(define Examples-depthExample3 (vector 3 1 2 (+ (Lemmas-lemma1LTESucc 1) 1) 3 (vector 0 2) (vector 3 2 0 3 (Lemmas-lemma1LTESucc 2) (vector 1 (Lemmas-lemma1LTESucc 1)) (vector 3 0 1 (Lemmas-lemma1LTESucc 2) (+ (Lemmas-lemma1LTESucc 1) 1) (vector 0 1) (vector 1 1 (+ (Lemmas-lemma1LTESucc 1) 1) (vector 2 3.141592653589793 1 (+ (Lemmas-lemma1LTESucc 1) 1) csegen-212))))))
(define Examples-drawDepthExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples of depth computation\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;\xa;The depth of the following circuit\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 3 Examples-depthExample2) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr (string-append (string-append "is " (PreludeC-45Show-u--show_Show_Nat (UnitaryLinear-depth 3 Examples-depthExample2))) "\xa;") ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;\xa;The depth of the following circuit\xa;" ext-0))) (let ((act-6 ((UnitaryLinear-draw 3 Examples-depthExample3) ext-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "is " (PreludeC-45Show-u--show_Show_Nat (UnitaryLinear-depth 3 Examples-depthExample3))) "\xa;") ext-0)))))))))
(define Examples-parametrized_example1 (lambda (arg-0) (cond ((equal? arg-0 1) UnitaryLinear-HGate) (else (UnitaryLinear-PGate 3.141592653589793)))))
(define Examples-parametrized_example2 (lambda (arg-0 arg-1 arg-2) (UnitaryLinear-compose UnitaryLinear-CNOTGate (UnitaryLinear-compose (cond ((equal? arg-0 1) csegen-178) (else (vector 0 ))) (cond ((equal? arg-1 1) (vector 0 )) (else (vector 2 arg-2 1 2 (vector 0 ))))))))
(define Examples-drawParamExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples of circuits parametrized by classical data\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : for b : bool , if b then HGate else PGate pi\xa;" ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "For b = True : \xa;" ext-0))) (let ((act-4 ((UnitaryLinear-draw 1 (Examples-parametrized_example1 1)) ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "For b = False : \xa;" ext-0))) (let ((act-6 ((UnitaryLinear-draw 1 (Examples-parametrized_example1 0)) ext-0))) (let ((act-7 (PreludeC-45IO-prim__putStr "Example 2 : for b1, b2 : Bool and p : Double , CNOTGate . (if b1 then H 0 IdGate else IdGate) . (if b2 then IdGate else P p 1 IdGate)\xa;" ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "For b1 = True, b2 = False, p = pi/2\xa;" ext-0))) ((UnitaryLinear-draw 2 (Examples-parametrized_example2 1 0 (/ 3.141592653589793 2.0))) ext-0)))))))))))
(define Examples-tensorExample1 (lambda () (UnitaryLinear-tensor 1 3 UnitaryLinear-HGate (UnitaryLinear-tensor 1 2 (UnitaryLinear-PGate 3.141592653589793) UnitaryLinear-CNOTGate))))
(define UnitaryLinear-tensorMap (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-0 0) (vector 0 ))(else (let ((e-0 (- arg-0 1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (UnitaryLinear-tensor arg-1 (* e-0 arg-1) e-4 (UnitaryLinear-tensorMap e-0 arg-1 e-5)))))))))
(define Examples-tensorMapExample (lambda () (UnitaryLinear-tensorMap 3 2 (cons UnitaryLinear-CNOTGate (cons Examples-toBellBasis (cons UnitaryLinear-CNOTGate '()))))))
(define UnitaryLinear-tensorMapSimple (lambda (arg-0 arg-1) (UnitaryLinear-tensorMap arg-0 1 arg-1)))
(define Examples-tensorMapSimpleExample (lambda () (UnitaryLinear-tensorMapSimple 3 (cons UnitaryLinear-HGate (cons (UnitaryLinear-PGate 3.141592653589793) (cons UnitaryLinear-HGate '()))))))
(define UnitaryLinear-tensorn (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (vector 0 ))(else (let ((e-0 (- arg-0 1))) (UnitaryLinear-tensor 1 e-0 arg-1 (UnitaryLinear-tensorn e-0 arg-1)))))))
(define Examples-tensornExample (lambda () (UnitaryLinear-tensorn 3 UnitaryLinear-HGate)))
(define Examples-drawTensorExamples (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Examples using tensor product\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example 1 : HGate # PGate pi # CNOTGate\xa;" ext-0))) (let ((act-3 ((UnitaryLinear-draw 4 (Examples-tensorExample1)) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "Example 2 : tensorn 3 HGate\xa;" ext-0))) (let ((act-5 ((UnitaryLinear-draw 3 (Examples-tensornExample)) ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "Example 3 : tensorMapSimple [HGate, PGate pi, HGate]\xa;" ext-0))) (let ((act-7 ((UnitaryLinear-draw 3 (Examples-tensorMapSimpleExample)) ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "Example 4 : tensorMap [CNOTGate, toBellBasis, CNOTGate]\xa;" ext-0))) ((UnitaryLinear-draw 6 (Examples-tensorMapExample)) ext-0)))))))))))
(define Examples-toBellBasis2 (lambda () (UnitaryLinear-compose UnitaryLinear-CNOTGate (UnitaryLinear-tensor 1 1 UnitaryLinear-HGate (vector 0 )))))
(define Examples-drawToBellBasis2 (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "\xa;Another possibility for toBellBasis: \xa;CNOTGate . (HGate # IdGate)\xa;" ext-0))) ((UnitaryLinear-draw 2 (Examples-toBellBasis2)) ext-0))))
(define Examples-exampleComposeTensor1 (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "\xa;An example of usage of compose, tensor and adjoint: \xa;(adjoint toBellBasis # IdGate) . (TGate # toBellBasis)\xa;" ext-0))) (((let ((u--circuit (UnitaryLinear-compose (UnitaryLinear-tensor 2 1 (UnitaryLinear-adjoint Examples-toBellBasis) (vector 0 )) (UnitaryLinear-tensor 1 2 UnitaryLinear-TGate Examples-toBellBasis)))) (lambda () (UnitaryLinear-draw 3 u--circuit)))) ext-0))))
(define Examples-drawExamples (lambda (ext-0) (let ((act-1 (Examples-drawComposeExamples ext-0))) (let ((act-2 (Examples-drawTensorExamples ext-0))) (let ((act-3 (Examples-drawToBellBasis2 ext-0))) (let ((act-4 (Examples-drawAdjointExamples ext-0))) (let ((act-5 (Examples-exampleComposeTensor1 ext-0))) (let ((act-6 (Examples-drawParamExamples ext-0))) (Examples-drawDepthExamples ext-0)))))))))
(define LinearTypes-C-43C-43 (lambda (arg-3 arg-4) (if (null? arg-3) arg-4 (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons e-3 (LinearTypes-C-43C-43 e-4 arg-4)))))))
(define UnitaryOp-reCombineSingleR (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (lambda (clam-0) (cond ((equal? arg-2 0) (if (null? arg-4) (cons clam-0 (cons arg-5 '())) (cons clam-0 (LinearTypes-C-43C-43 arg-4 (cons arg-5 '())))))(else (cons clam-0 (LinearTypes-C-43C-43 arg-4 (cons arg-5 '()))))))))
(define UnitaryOp-splitLastUtil (lambda (arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-2 0) (lambda (clam-0) (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (cons clam-0 (cons '() (cons e-3 '())))))))(else (let ((e-0 (- arg-2 1))) (cond ((equal? e-0 0) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (lambda (clam-1) (let ((e-13 (car e-10))) (let ((e-14 (cdr e-10))) (cons clam-1 (cons (cons e-9 '()) (cons e-13 '())))))))))(else (let ((e-6 (- e-0 1))) (lambda (clam-2) (let ((e-18 (car arg-4))) (let ((e-19 (cdr arg-4))) (UStateT-C-62C-62C-61 (UnitaryOp-splitLastUtil arg-1 (+ e-6 1) arg-3 e-19) (lambda (_-0) (lambda (clam-3) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-3 (cons (cons e-18 e-2) e-3)))))) clam-2))))))))))))
(define VQE-encodingUnitaryOp (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (cond ((equal? arg-3 0) (lambda (clam-0) (let ((e-4 (car arg-5))) (let ((e-5 (cdr arg-5))) (cons clam-0 (cons e-4 e-5))))))(else (let ((e-0 (- arg-3 1))) (let ((e-8 (car arg-4))) (let ((e-9 (cdr arg-4))) (lambda (clam-1) (cond ((equal? e-8 0) (let ((e-12 (car arg-5))) (let ((e-13 (cdr arg-5))) (UStateT-C-62C-62C-61 (UnitaryOp-splitLastUtil arg-1 (+ e-0 1) arg-2 (cons e-12 e-13)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-2) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (UStateT-C-62C-62C-61 (VQE-encodingUnitaryOp arg-1 arg-2 e-0 e-9 e-2) (lambda (_-1) (lambda (clam-3) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (UnitaryOp-reCombineSingleR arg-1 (+ e-0 1) arg-2 (cons e-5 e-4) e-6) (lambda (u--combined) (lambda (eta-0) (cons eta-0 u--combined))) clam-3))))) clam-2))))))) clam-1)))) ((equal? e-8 1) (let ((e-16 (car arg-5))) (let ((e-17 (cdr arg-5))) (UStateT-C-62C-62C-61 (UnitaryOp-splitLastUtil arg-1 (+ e-0 1) arg-2 (cons e-16 e-17)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-3) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (UStateT-C-62C-62C-61 (VQE-encodingUnitaryOp arg-1 arg-2 e-0 e-9 e-2) (lambda (_-1) (lambda (clam-6) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (let ((e-18 (vector-ref arg-1 3))) ((e-18 arg-2) e-6)) (lambda (_-2) (lambda (clam-4) (let ((e-11 (car _-2))) (let ((e-10 (cdr _-2))) (UStateT-C-62C-62C-61 (let ((e-18 (vector-ref arg-1 5))) (((e-18 arg-2) e-11) e-5)) (lambda (_-3) (let ((e-13 (car _-3))) (let ((e-12 (cdr _-3))) (lambda (clam-5) (let ((e-15 (car e-12))) (let ((e-14 (cdr e-12))) (UStateT-C-62C-62C-61 (UnitaryOp-reCombineSingleR arg-1 (+ e-0 1) arg-2 (cons e-15 e-4) e-13) csegen-227 clam-5))))))) clam-4))))) clam-6))))) clam-3))))))) clam-1)))) ((equal? e-8 2) (let ((e-20 (car arg-5))) (let ((e-21 (cdr arg-5))) (UStateT-C-62C-62C-61 (UnitaryOp-splitLastUtil arg-1 (+ e-0 1) arg-2 (cons e-20 e-21)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-6) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (UStateT-C-62C-62C-61 (VQE-encodingUnitaryOp arg-1 arg-2 e-0 e-9 e-2) (lambda (_-1) (lambda (clam-11) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (let ((e-16 (vector-ref arg-1 3))) ((e-16 arg-2) e-6)) (lambda (_-2) (lambda (clam-7) (let ((e-11 (car _-2))) (let ((e-10 (cdr _-2))) (UStateT-C-62C-62C-61 (let ((e-16 (vector-ref arg-1 5))) (((e-16 arg-2) e-11) e-5)) (lambda (_-3) (let ((e-13 (car _-3))) (let ((e-12 (cdr _-3))) (lambda (clam-8) (let ((e-15 (car e-12))) (let ((e-14 (cdr e-12))) (UStateT-C-62C-62C-61 (UnitaryOp-reCombineSingleR arg-1 (+ e-0 1) arg-2 (cons e-15 e-4) e-13) csegen-227 clam-8))))))) clam-7))))) clam-11))))) clam-6))))))) clam-1)))) (else (let ((e-24 (car arg-5))) (let ((e-25 (cdr arg-5))) (UStateT-C-62C-62C-61 (UnitaryOp-splitLastUtil arg-1 (+ e-0 1) arg-2 (cons e-24 e-25)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-9) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (UStateT-C-62C-62C-61 (VQE-encodingUnitaryOp arg-1 arg-2 e-0 e-9 e-2) (lambda (_-1) (lambda (clam-16) (let ((e-5 (car _-1))) (let ((e-4 (cdr _-1))) (UStateT-C-62C-62C-61 (let ((e-14 (vector-ref arg-1 5))) (((e-14 arg-2) e-6) e-5)) (lambda (_-2) (let ((e-11 (car _-2))) (let ((e-10 (cdr _-2))) (lambda (clam-10) (let ((e-13 (car e-10))) (let ((e-12 (cdr e-10))) (UStateT-C-62C-62C-61 (UnitaryOp-reCombineSingleR arg-1 (+ e-0 1) arg-2 (cons e-13 e-4) e-11) csegen-227 clam-10))))))) clam-16))))) clam-9))))))) clam-1)))))))))))))
(define Qubit-stupidQubitList (cons 0 (cons 0 (cons 3 '()))))
(define UnitarySimulated-duplicateLinU (lambda (arg-1) (case (vector-ref arg-1 0) ((0) (cons (vector 0 ) (vector 0 ))) ((1) (let ((e-2 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 2))) (let ((e-4 (vector-ref arg-1 3))) (let ((sc1 (UnitarySimulated-duplicateLinU e-4))) (let ((e-6 (car sc1))) (let ((e-5 (cdr sc1))) (cons (vector 1 e-2 e-3 e-6) (vector 1 e-2 e-3 e-5))))))))) ((2) (let ((e-6 (vector-ref arg-1 1))) (let ((e-7 (vector-ref arg-1 2))) (let ((e-8 (vector-ref arg-1 3))) (let ((e-9 (vector-ref arg-1 4))) (let ((sc1 (UnitarySimulated-duplicateLinU e-9))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons (vector 2 e-6 e-7 e-8 e-2) (vector 2 e-6 e-7 e-8 e-3)))))))))) (else (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((e-13 (vector-ref arg-1 3))) (let ((e-14 (vector-ref arg-1 4))) (let ((e-15 (vector-ref arg-1 5))) (let ((e-16 (vector-ref arg-1 6))) (let ((sc1 (UnitarySimulated-duplicateLinU e-16))) (let ((e-2 (car sc1))) (let ((e-3 (cdr sc1))) (cons (vector 3 e-11 e-12 e-13 e-14 e-15 e-2) (vector 3 e-11 e-12 e-13 e-14 e-15 e-3)))))))))))))))
(define UnitarySimulated-case--caseC-32blockC-32inC-32invert-3252 (lambda (arg-2 arg-5 arg-6) (let ((e-2 (car arg-6))) (let ((u--invu (UnitaryLinear-adjoint e-2))) (let ((sc1 (UnitarySimulated-duplicateLinU arg-2))) (let ((e-5 (car sc1))) (let ((u--unew (UnitaryLinear-compose u--invu e-5))) (cons u--unew arg-5))))))))
(define UnitarySimulated-invert (lambda (arg-2 arg-3) (let ((sc0 (arg-2 (vector 0 )))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (UnitarySimulated-case--caseC-32blockC-32inC-32invert-3252 arg-3 e-3 (UnitarySimulated-duplicateLinU e-2)))))))
(define UnitarySimulated-adjointUSTC-39 (lambda (arg-2 ext-0) (UnitarySimulated-invert arg-2 ext-0)))
(define UnitarySimulated-u--adjointUST_UnitaryOp_Unitary (lambda (ext-1 ext-0) (UnitarySimulated-adjointUSTC-39 ext-1 ext-0)))
(define UnitarySimulated-case--applyUnitaryC-39-2191 (lambda (arg-0 arg-1 arg-2 arg-3 arg-5) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (cons (UnitaryLinear-apply arg-1 arg-0 arg-3 arg-2 e-3 (cons (Injection-findProofAllDiffOrFail e-3) (Injection-findProofAllSmallerOrFail arg-0 e-3))) e-2)))))
(define UnitarySimulated-applyUnitaryC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (UnitarySimulated-case--applyUnitaryC-39-2191 arg-0 arg-1 arg-4 arg-3 (Qubit-distributeDupedLVectVect arg-2))))
(define UnitarySimulated-applyInternal (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-applyCNOTSim (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 2 (cons arg-1 (cons arg-2 '())) UnitaryLinear-CNOTGate eta-0)) (lambda (_-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (lambda (clam-0) (let ((e-6 (car e-3))) (let ((e-7 (cdr e-3))) (cons clam-0 (cons e-2 (cons e-6 '()))))))))) ext-0)))
(define UnitarySimulated-u--applyCNOT_UnitaryOp_Unitary (lambda (arg-0 ext-2 ext-1 ext-0) (UnitarySimulated-applyCNOTSim arg-0 ext-2 ext-1 ext-0)))
(define Qubit-makeNeutralVectC-39 (lambda (arg-0) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cons e-0 (Qubit-makeNeutralVectC-39 e-0)))))))
(define DataC-45Vect-reverseOnto (lambda (arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (DataC-45Vect-reverseOnto (cons e-3 arg-3) e-4))))))
(define DataC-45Vect-reverse (lambda (ext-0) (DataC-45Vect-reverseOnto '() ext-0)))
(define Qubit-makeNeutralVect (lambda (arg-0) (DataC-45Vect-reverse (Qubit-makeNeutralVectC-39 arg-0))))
(define UnitarySimulated-case--applyControlSimulatedC-39-2393 (lambda (arg-0 arg-1 arg-2 arg-3 arg-5) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((u--vn (Qubit-findInLinQ arg-1 e-2 (Qubit-makeNeutralVect (+ arg-1 1))))) (let ((sc1 (arg-3 (vector 0 )))) (let ((e-5 (car sc1))) (let ((e-4 (cdr sc1))) (let ((u--unew (UnitaryLinear-apply (+ arg-1 1) (+ arg-1 1) (UnitaryLinear-controlled arg-1 e-5) arg-2 (cons e-3 u--vn) (cons (Injection-findProofAllDiffOrFail (cons e-3 u--vn)) (Injection-findProofAllSmallerOrFail (+ arg-1 1) (cons e-3 u--vn)))))) (cons u--unew (cons e-2 e-4)))))))))))
(define UnitarySimulated-applyControlSimulatedC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (UnitarySimulated-case--applyControlSimulatedC-39-2393 arg-1 arg-0 arg-4 arg-3 (cons arg-2 arg-2))))
(define UnitarySimulated-applyControlAbsSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyControlSimulatedC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyControlledAbs_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyControlAbsSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-applyHSim (lambda (arg-0 arg-1 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 1 (cons arg-1 '()) UnitaryLinear-HGate eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitarySimulated-u--applyH_UnitaryOp_Unitary (lambda (arg-0 ext-1 ext-0) (UnitarySimulated-applyHSim arg-0 ext-1 ext-0)))
(define UnitarySimulated-applyPSim (lambda (arg-0 arg-1 arg-2 ext-0) (UStateT-C-62C-62C-61 (lambda (eta-0) (UnitarySimulated-applyInternal arg-0 1 (cons arg-2 '()) (UnitaryLinear-PGate arg-1) eta-0)) (lambda (_-0) (lambda (clam-0) (let ((e-2 (car _-0))) (let ((e-3 (cdr _-0))) (cons clam-0 (cons e-2 '())))))) ext-0)))
(define UnitarySimulated-u--applyP_UnitaryOp_Unitary (lambda (arg-0 ext-2 ext-1 ext-0) (UnitarySimulated-applyPSim arg-0 ext-2 ext-1 ext-0)))
(define UnitarySimulated-case--applyUnitaryAbsC-39-2639 (lambda (arg-0 arg-1 arg-3 arg-4) (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (let ((sc1 (arg-3 e-2))) (let ((e-5 (car sc1))) (let ((e-4 (cdr sc1))) (let ((u--ufinal (UnitaryLinear-compose e-5 e-3))) (cons u--ufinal e-4)))))))))
(define UnitarySimulated-applyUnitaryAbsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (UnitarySimulated-case--applyUnitaryAbsC-39-2639 arg-0 arg-1 arg-2 (UnitarySimulated-duplicateLinU arg-3))))
(define UnitarySimulated-applyUnitaryAbsSimulated (lambda (arg-0 arg-1 arg-2 ext-0) (UnitarySimulated-applyUnitaryAbsC-39 arg-0 arg-1 arg-2 ext-0)))
(define UnitarySimulated-u--applyUnitaryAbs_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-1 ext-0) (UnitarySimulated-applyUnitaryAbsSimulated arg-0 arg-1 ext-1 ext-0)))
(define UnitarySimulated-case--applyUnitaryOwnC-39-2279 (lambda (arg-0 arg-1 arg-2 arg-3 arg-5) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (cons (UnitaryLinear-apply arg-1 arg-0 arg-3 arg-2 e-3 (cons (Injection-findProofAllDiffOrFail e-3) (Injection-findProofAllSmallerOrFail arg-0 e-3))) e-2)))))
(define UnitarySimulated-applyUnitaryOwnC-39 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (UnitarySimulated-case--applyUnitaryOwnC-39-2279 arg-0 arg-1 arg-4 arg-3 (Qubit-distributeDupedLVectVect arg-2))))
(define UnitarySimulated-applyUnitaryOwnSimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryOwnC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyUnitaryOwn_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyUnitaryOwnSimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-applyUnitarySimulated (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (UnitarySimulated-applyUnitaryC-39 arg-0 arg-1 arg-2 arg-3 ext-0)))
(define UnitarySimulated-u--applyUnitary_UnitaryOp_Unitary (lambda (arg-0 arg-1 ext-2 ext-1 ext-0) (UnitarySimulated-applyUnitarySimulated arg-0 arg-1 ext-2 ext-1 ext-0)))
(define UnitarySimulated-u--exportSelf_UnitaryOp_Unitary (lambda (arg-1 arg-2 arg-3) (let ((sc0 (arg-3 arg-2))) (let ((e-2 (car sc0))) e-2))))
(define UnitarySimulated-u--run_UnitaryOp_Unitary (lambda (arg-1 ext-0 ext-1) (ext-1 ext-0)))
(define Main-encodingTest (lambda () (let ((u--p csegen-60)) (let ((u--qs Qubit-stupidQubitList)) (UStateT-C-62C-62C-61 (VQE-encodingUnitaryOp (vector (lambda (u--n) (lambda (u--i) (lambda (arg-1261) (lambda (arg-1264) (lambda (eta-0) (UnitarySimulated-u--applyUnitary_UnitaryOp_Unitary u--n u--i arg-1261 arg-1264 eta-0)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1277) (lambda (u--ownUnitary) (lambda (eta-0) (UnitarySimulated-u--applyUnitaryOwn_UnitaryOp_Unitary u--n u--i arg-1277 u--ownUnitary eta-0)))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1292) (lambda (eta-0) (UnitarySimulated-u--applyUnitaryAbs_UnitaryOp_Unitary u--n u--i arg-1292 eta-0))))) (lambda (u--n) (lambda (arg-1302) (lambda (eta-0) (UnitarySimulated-u--applyH_UnitaryOp_Unitary u--n arg-1302 eta-0)))) (lambda (u--n) (lambda (arg-1314) (lambda (arg-1317) (lambda (eta-0) (UnitarySimulated-u--applyP_UnitaryOp_Unitary u--n arg-1314 arg-1317 eta-0))))) (lambda (u--n) (lambda (arg-1330) (lambda (arg-1333) (lambda (eta-0) (UnitarySimulated-u--applyCNOT_UnitaryOp_Unitary u--n arg-1330 arg-1333 eta-0))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1348) (lambda (arg-1351) (lambda (eta-0) (UnitarySimulated-u--applyControlledAbs_UnitaryOp_Unitary u--n u--i arg-1348 arg-1351 eta-0)))))) (lambda (u--i) (lambda (u--n) (lambda (arg-1363) (lambda (eta-0) (UnitarySimulated-u--adjointUST_UnitaryOp_Unitary arg-1363 eta-0))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1371) (lambda (arg-1374) (UnitarySimulated-u--run_UnitaryOp_Unitary u--i arg-1371 arg-1374))))) (lambda (u--n) (lambda (u--i) (lambda (arg-1384) (lambda (arg-1387) (UnitarySimulated-u--exportSelf_UnitaryOp_Unitary u--i arg-1384 arg-1387)))))) 3 2 u--p u--qs) (lambda (u--out) (lambda (eta-0) (cons eta-0 u--out))) (vector 0 ))))))
(define Main-encodingTestIo (lambda (ext-0) (Main-case--encodingTestIo-10081 (Main-encodingTest) ext-0)))
(define Main-main (lambda (ext-0) (let ((act-1 (Examples-drawExamples ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;Test coin toss by performing 1000 coin tosses.\xa;" ext-0))) (let ((act-3 ((Main-testCoins) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "\xa;Test 'Repeat Until Success'. Probability to measure '1' is 2/3 for this example.\xa;" ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;Small test with VQE\xa;" ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "\xa;Small test with Encoding in VQE\xa;" ext-0))) (let ((act-7 (Main-encodingTestIo ext-0))) (vector 0 ))))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (let ((eff-0 (arg-1 u--w))) eff-0)))))
(collect-request-handler (lambda () (collect) (blodwen-run-finalisers)))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))
  (collect 4)
  (blodwen-run-finalisers)
  
  )